<scope doc="This modules provides commonly-used tools for functional&#10;programming." ilk="blob" lang="Python" name="__init__" src="d:\Program Files (x86)\Python35-32\lib\site-packages\functional\__init__.py"><import line="569" module="operator" symbol="add" /><scope classrefs="object" doc="new function with partial application" ilk="class" line="28" lineend="62" name="partial" signature="partial(func, *args, **keywords)"><scope attributes="__ctor__" ilk="function" line="33" lineend="40" name="__init__" signature="partial(**func)"><variable attributes="varargs" citdl="partial" ilk="argument" line="33" name="self" /><variable attributes="kwargs" ilk="argument" line="33" name="func" /></scope><variable attributes="__instancevar__" line="37" name="func" /><variable attributes="__instancevar__" citdl="tuple()" line="38" name="args" /><variable attributes="__instancevar__" citdl="dict()" line="39" name="kwargs" /><variable attributes="protected __instancevar__" line="40" name="_dict" /><scope ilk="function" line="42" lineend="48" name="__call__" returns="partial.func()" signature="__call__()"><variable attributes="kwargs" citdl="partial" ilk="argument" line="42" name="self" /><variable line="43" name="applied_args" /><variable citdl="dict()" line="45" name="applied_kwargs" /></scope><scope attributes="protected" ilk="function" line="50" lineend="52" name="_getdict" returns="dict()" signature="_getdict()"><variable citdl="partial" ilk="argument" line="50" name="self" /></scope><scope attributes="protected" ilk="function" line="54" lineend="57" name="_setdict" signature="_setdict(val)"><variable citdl="partial" ilk="argument" line="54" name="self" /><variable ilk="argument" line="54" name="val" /></scope><scope attributes="protected" ilk="function" line="59" lineend="60" name="_deldict" signature="_deldict()"><variable citdl="partial" ilk="argument" line="59" name="self" /></scope><variable citdl="property()" line="62" name="__dict__" /></scope><scope doc="The function returned by compose is a composition of func_1 and func_2.&#10;That is, compose(func_1, func_2)(5) == func_1(func_2(5))" ilk="function" line="67" lineend="81" name="compose" returns="compose.composition" signature="compose(func_1, func_2) -&gt; function"><variable ilk="argument" line="67" name="func_1" /><variable ilk="argument" line="67" name="func_2" /><scope ilk="function" line="79" lineend="80" name="composition" returns="compose.func_1()" signature="composition()" /></scope><scope attributes="protected" ilk="function" line="86" lineend="92" name="_foldl" returns="_foldl()" signature="_foldl(func, base, itr)"><variable ilk="argument" line="86" name="func" /><variable ilk="argument" line="86" name="base" /><variable ilk="argument" line="86" name="itr" /><variable citdl="itr.next()" line="88" name="first" /></scope><scope doc="Takes a binary function, a starting value (usually some kind of 'zero'), and&#10;an iterable. The function is applied to the starting value and the first&#10;element of the list, then the result of that and the second element of the&#10;list, then the result of that and the third element of the list, and so on.&#10;&#10;foldl(add, 0, [1, 2, 3]) is equivalent to add(add(add(0, 1), 2), 3)" ilk="function" line="94" lineend="105" name="foldl" returns="_foldl()" signature="foldl(function, start, iterable) -&gt; object"><variable ilk="argument" line="94" name="func" /><variable ilk="argument" line="94" name="start" /><variable ilk="argument" line="94" name="itr" /></scope><scope attributes="protected" ilk="function" line="110" lineend="116" name="_foldr" returns="_foldr.func()" signature="_foldr(func, base, itr)"><variable ilk="argument" line="110" name="func" /><variable ilk="argument" line="110" name="base" /><variable ilk="argument" line="110" name="itr" /><variable citdl="itr.next()" line="112" name="first" /></scope><scope doc="Like foldl, but starts from the end of the iterable and works back toward the&#10;beginning. For example, foldr(subtract, 0, [1, 2, 3]) == 2, but&#10;foldl(subtract, 0, [1, 2, 3] == -6&#10;&#10;foldr(add, 0, [1, 2, 3]) is equivalent to add(1, add(2, add(3, 0)))" ilk="function" line="118" lineend="128" name="foldr" returns="_foldr()" signature="foldr(function, start, iterable) -&gt; object"><variable ilk="argument" line="118" name="func" /><variable ilk="argument" line="118" name="start" /><variable ilk="argument" line="118" name="itr" /></scope><scope doc="Like foldl, but can only operate on non-empty lists." ilk="function" line="133" lineend="146" name="foldl1" returns="_foldl()" signature="foldl1(function, iterable) -&gt; object"><variable ilk="argument" line="133" name="func" /><variable citdl="iter()" ilk="argument" line="133" name="itr" /><variable citdl="itr.next()" line="142" name="first" /></scope><scope doc="Like foldr, but can only operate on non-empty lists." ilk="function" line="151" lineend="164" name="foldr1" returns="_foldr()" signature="foldr1(function, iterable) -&gt; object"><variable ilk="argument" line="151" name="func" /><variable citdl="iter()" ilk="argument" line="151" name="itr" /><variable citdl="itr.next()" line="160" name="first" /></scope><scope attributes="protected" doc="In Haskell:&#10;&#10;scanl        :: (a -&gt; b -&gt; a) -&gt; a -&gt; [a] -&gt; [a]&#10;scanl f q xs =  q : (case xs of&#10;                          [] -&gt; []&#10;                        x:xs -&gt; scanl f (f q x) xs)" ilk="function" line="169" lineend="183" name="_scanl" signature="_scanl(func, base, itr)"><variable ilk="argument" line="169" name="func" /><variable citdl="func()" ilk="argument" line="169" name="base" /><variable ilk="argument" line="169" name="itr" /><variable line="180" name="o" /></scope><scope doc="Like foldl, but produces a list of successively reduced values, starting&#10;from the left.&#10;scanr(f, 0, [1, 2, 3]) is equivalent to&#10;[0, f(0, 1), f(f(0, 1), 2), f(f(f(0, 1), 2), 3)]&#10;&#10;scanl returns a iterator over the result list. This is done so that the&#10;list may be calculated lazily." ilk="function" line="185" lineend="201" name="scanl" returns="_scanl()" signature="scanl(func, start, iterable) -&gt; iterator"><variable ilk="argument" line="185" name="func" /><variable ilk="argument" line="185" name="start" /><variable citdl="iter()" ilk="argument" line="185" name="itr" /></scope><scope doc="Like scanl, but can only operate on non-empty lists." ilk="function" line="206" lineend="222" name="scanl1" returns="_scanl()" signature="scanl1(function, iterable) -&gt; object"><variable ilk="argument" line="206" name="func" /><variable citdl="iter()" ilk="argument" line="206" name="itr" /><variable citdl="itr.next()" line="218" name="first" /></scope><scope attributes="protected" doc="In Haskell:&#10;&#10;scanr             :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; [b]&#10;scanr f q0 []     =  [q0]&#10;scanr f q0 (x:xs) =  f x q : qs&#10;                     where qs@(q:_) = scanr f q0 xs" ilk="function" line="227" lineend="252" name="_scanr" signature="_scanr(func, q0, x_xs)"><variable ilk="argument" line="227" name="func" /><variable ilk="argument" line="227" name="q0" /><variable ilk="argument" line="227" name="x_xs" /><variable citdl="x_xs.next()" line="239" name="x" /><variable citdl="()" line="244" name="qs" /><variable citdl="qs.next()" line="246" name="q" /></scope><scope doc="Like foldr, but produces a list of successively reduced values, starting&#10;from the right.&#10;scanr(f, 0, [1, 2, 3]) is equivalent to&#10;[f(1, f(2, f(3, 0))), f(2, f(3, 0)), f(3, 0), 0]&#10;&#10;scanl returns a iterator over the result list. This is done so that the&#10;list may be calculated lazily." ilk="function" line="254" lineend="270" name="scanr" returns="_scanr()" signature="scanr(func, start, iterable) -&gt; iterator"><variable ilk="argument" line="254" name="func" /><variable ilk="argument" line="254" name="start" /><variable citdl="iter()" ilk="argument" line="254" name="itr" /></scope><scope doc="Like scanr, but can only operate on non-empty lists." ilk="function" line="275" lineend="291" name="scanr1" returns="_scanr()" signature="scanr1(function, iterable) -&gt; object"><variable ilk="argument" line="275" name="func" /><variable citdl="iter()" ilk="argument" line="275" name="itr" /><variable citdl="itr.next()" line="287" name="first" /></scope><scope doc="Takes an object and returns an iterator over an infinite list of this&#10;object." ilk="function" line="296" lineend="304" name="repeat" signature="repeat(obj) -&gt; iterator"><variable ilk="argument" line="296" name="obj" /></scope><scope attributes="protected" doc="In Haskell:&#10;&#10;cycle    :: [a] -&gt; [a]&#10;cycle [] =  error &quot;Prelude.cycle empty list&quot;&#10;cycle xs =  xs' where xs' = xs ++ xs'" ilk="function" line="309" lineend="328" name="_cycle" signature="_cycle(first, itr)"><variable ilk="argument" line="309" name="first" /><variable ilk="argument" line="309" name="itr" /><variable citdl="list" line="319" name="seq" /><variable line="322" name="o" /></scope><scope doc="Take an iterable object and repeat it to infinity. For example,&#10;cycle([1, 2, 3]) = [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, ...]&#10;&#10;cycle returns a generator so this infinite list can be calculated lazily" ilk="function" line="330" lineend="346" name="cycle" returns="_cycle()" signature="cycle(iterable) -&gt; generator"><variable citdl="iter()" ilk="argument" line="330" name="itr" /><variable citdl="itr.next()" line="342" name="first" /></scope><scope attributes="protected" doc="In Haskell:&#10;&#10;iterate     :: (a -&gt; a) -&gt; a -&gt; [a]&#10;iterate f x =  x : iterate f (f x)" ilk="function" line="351" lineend="360" name="_iterate" signature="_iterate(func, obj)"><variable ilk="argument" line="351" name="func" /><variable citdl="func()" ilk="argument" line="351" name="obj" /></scope><scope doc="iterate takes a callable and an object and returns a generator. This&#10;generator will yield repeated applications of `func`; for example,&#10;iterate(f, 5) is equivalent to [5, f(5), f(f(5)), f(f(f(5))), ...]" ilk="function" line="362" lineend="373" name="iterate" returns="_iterate()" signature="iterate(function, obj) -&gt; generator"><variable ilk="argument" line="362" name="func" /><variable ilk="argument" line="362" name="obj" /></scope><scope attributes="protected" doc="In Haskell:&#10;&#10;take                   :: Int -&gt; [a] -&gt; [a]&#10;take n _      | n &lt;= 0 =  []&#10;take _ []              =  []&#10;take n (x:xs)          =  x : take (n-1) xs" ilk="function" line="378" lineend="390" name="_take" signature="_take(n, itr)"><variable ilk="argument" line="378" name="n" /><variable ilk="argument" line="378" name="itr" /></scope><scope doc="take takes a number and an iterable and returns a generator. Effectively,&#10;take is like a flexible version of slicing that works on all iteratables,&#10;not just sequences. For example:&#10;take(4, xrange(0, 30, 6)) == [0, 6, 12, 18]&#10;&#10;The generator is used so that the resulting list can be calculated lazily." ilk="function" line="392" lineend="406" name="take" returns="_take()" signature="take(n, iterable) -&gt; generator"><variable citdl="int()" ilk="argument" line="392" name="n" /><variable citdl="iter()" ilk="argument" line="392" name="itr" /></scope><scope attributes="protected" doc="In Haskell:&#10;&#10;drop                   :: Int -&gt; [a] -&gt; [a]&#10;drop n xs     | n &lt;= 0 =  xs&#10;drop _ []              =  []&#10;drop n (x:xs)          =  drop (n-1) xs" ilk="function" line="411" lineend="426" name="_drop" signature="_drop(n, itr)"><variable ilk="argument" line="411" name="n" /><variable ilk="argument" line="411" name="itr" /></scope><scope doc="drop takes a number and an iterable and returns a generator. Like take,&#10;drop is like a flexible version of slicing that works on all iteratables,&#10;not just sequences. For example:&#10;xrange(0, 30, 6)          == [0, 6, 12, 18, 24]&#10;drop(2, xrange(0, 30, 6)) == [12, 18, 24]&#10;&#10;The generator is used so that the resulting list can be calculated lazily." ilk="function" line="428" lineend="443" name="drop" returns="_drop()" signature="drop(n, iterable) -&gt; generator"><variable citdl="int()" ilk="argument" line="428" name="n" /><variable citdl="iter()" ilk="argument" line="428" name="itr" /></scope><scope doc="flip causes `func` to take its first two arguments in reverse order. The&#10;returned function is a wrapper around `func` that makes this happen." ilk="function" line="448" lineend="460" name="flip" returns="flip.flipped_func" signature="flip(func) -&gt; function"><variable ilk="argument" line="448" name="func" /><scope ilk="function" line="458" lineend="459" name="flipped_func" returns="flip.func()" signature="flipped_func(*arg_1, **arg_2)"><variable attributes="varargs" ilk="argument" line="458" name="arg_1" /><variable attributes="kwargs" ilk="argument" line="458" name="arg_2" /></scope></scope><scope attributes="protected" doc="In Haskell:&#10;&#10;takeWhile               :: (a -&gt; Bool) -&gt; [a] -&gt; [a]&#10;takeWhile p []          =  []&#10;takeWhile p (x:xs)&#10;            | p x       =  x : takeWhile p xs&#10;            | otherwise =  []" ilk="function" line="465" lineend="479" name="_takeWhile" signature="_takeWhile(predicate, itr)"><variable ilk="argument" line="465" name="predicate" /><variable ilk="argument" line="465" name="itr" /><variable citdl="itr.next()" line="476" name="obj" /></scope><scope doc="Like take, except instead of a numeric constant, the length of the&#10;resulting list is determined by the `predicate` function. The function&#10;will be passed successive elements from the `iterable` parameter; if&#10;`predicate` returns a true value, that element goes in the list and we move&#10;to the next element. As soon as `predicate` returns a false value,&#10;iteration terminates and the slice is finished.&#10;&#10;def pred(a):&#10;    if a &lt; 5: return True&#10;    return False&#10;&#10;takeWhile(pred, [3, 4, 5, 6]) == [3, 4]" ilk="function" line="481" lineend="502" name="takeWhile" returns="_takeWhile()" signature="takeWhile(predicate, iterable) -&gt; generator"><variable ilk="argument" line="481" name="predicate" /><variable citdl="iter()" ilk="argument" line="481" name="itr" /></scope><scope attributes="protected" doc="In Haskell:&#10;&#10;dropWhile               :: (a -&gt; Bool) -&gt; [a] -&gt; [a]&#10;dropWhile p []          =  []&#10;dropWhile p xs@(x:xs')&#10;            | p x       =  dropWhile p xs'&#10;            | otherwise =  xs" ilk="function" line="507" lineend="525" name="_dropWhile" signature="_dropWhile(predicate, itr)"><variable ilk="argument" line="507" name="predicate" /><variable ilk="argument" line="507" name="itr" /><variable citdl="itr.next()" line="518" name="obj" /></scope><scope doc="Like drop, except instead of a numeric constant, the length of the&#10;dropped slice is determined by the `predicate` function. The function&#10;will be passed successive elements from the `iterable` parameter; if&#10;`predicate` returns a true value, we move to the next element. As soon&#10;as `predicate` returns a false value, iteration terminates and the&#10;remaining portion of the iterable is returned.&#10;&#10;def pred(a):&#10;    if a &lt; 5: return True&#10;    return False&#10;&#10;dropWhile(pred, [3, 4, 5, 6]) == [5, 6]" ilk="function" line="527" lineend="548" name="dropWhile" returns="_dropWhile()" signature="dropWhile(predicate, iterable) -&gt; generator"><variable ilk="argument" line="527" name="predicate" /><variable citdl="iter()" ilk="argument" line="527" name="itr" /></scope><scope doc="The identity function. id(obj) returns obj unchanged.&#10;&#10;&gt;&gt;&gt; obj = object()&#10;&gt;&gt;&gt; id(obj) is obj&#10;True" ilk="function" line="553" lineend="563" name="id" signature="id(obj) -&gt; object"><variable ilk="argument" line="553" name="obj" /></scope><scope ilk="function" line="571" lineend="572" name="add" signature="add(a, b)"><variable ilk="argument" line="571" name="a" /><variable ilk="argument" line="571" name="b" /></scope><scope doc="concat takes an iterable of lists and concatenates the sublists.&#10;&#10;&gt;&gt;&gt; concat([[1], [2], [3]])&#10;[1, 2, 3]&#10;&gt;&gt;&gt;" ilk="function" line="574" lineend="586" name="concat" returns="_foldr()" signature="concat(iterable) -&gt; list"><variable citdl="iter()" ilk="argument" line="574" name="itr" /></scope><scope doc="concatMap is a composition of concat and map. Note that the `func`&#10;callable must return lists, not single values&#10;&#10;&gt;&gt;&gt; def double(x_xs): return [x_xs[0], x_xs[0]]&#10;...&#10;&gt;&gt;&gt; concatMap(double, [[1], [2], [3]])&#10;[1, 1, 2, 2, 3, 3]&#10;&gt;&gt;&gt;" ilk="function" line="591" lineend="608" name="concatMap" returns="concat()" signature="concatMap(func, iterable) -&gt; list"><variable ilk="argument" line="591" name="func" /><variable citdl="iter()" ilk="argument" line="591" name="itr" /></scope><scope doc="splitAt(n, iterable) == (take(n, iterable), drop(n, iterable))" ilk="function" line="613" lineend="619" name="splitAt" returns="tuple" signature="splitAt(n, iterable) -&gt; (generator, generator)"><variable ilk="argument" line="613" name="n" /><variable ilk="argument" line="613" name="itr" /></scope></scope>