<scope doc="datetime.tzinfo timezone definitions generated from the&#10;Olson timezone database:" ilk="blob" lang="Python" name="__init__" src="d:\Program Files (x86)\Python35-32\lib\site-packages\pytz\__init__.py"><import line="26" module="sys" /><import line="26" module="datetime" /><import line="26" module="os.path" /><import line="26" module="gettext" /><import line="29" module="pkg_resources" symbol="resource_stream" /><import line="33" module="pytz.exceptions" symbol="AmbiguousTimeError" /><import line="34" module="pytz.exceptions" symbol="InvalidTimeError" /><import line="35" module="pytz.exceptions" symbol="NonExistentTimeError" /><import line="36" module="pytz.exceptions" symbol="UnknownTimeZoneError" /><import line="37" module="pytz.lazy" symbol="LazyDict" /><import line="37" module="pytz.lazy" symbol="LazyList" /><import line="37" module="pytz.lazy" symbol="LazySet" /><import line="38" module="pytz.tzinfo" symbol="unpickler" /><import line="39" module="pytz.tzfile" symbol="build_tzinfo" /><import line="39" module="pytz.tzfile" symbol="_byte_string" /><variable citdl="str" line="12" name="OLSON_VERSION" /><variable citdl="str" line="13" name="VERSION" /><variable citdl="str" line="14" name="__version__" /><variable citdl="str" line="16" name="OLSEN_VERSION" /><variable citdl="list" line="18" name="__all__" /><variable line="31" name="resource_stream" /><variable line="49" name="str" /><scope doc="&gt;&gt;&gt; ascii('Hello')&#10;'Hello'&#10;&gt;&gt;&gt; ascii(u'Hello')&#10;'Hello'&#10;&gt;&gt;&gt; ascii(u'\N{TRADE MARK SIGN}') #doctest: +IGNORE_EXCEPTION_DETAIL&#10;Traceback (most recent call last):&#10;    ...&#10;UnicodeEncodeError: ..." ilk="function" line="65" lineend="76" name="ascii" returns="s.encode()" signature="ascii(s)"><variable ilk="argument" line="65" name="s" /></scope><scope doc="Open a resource from the zoneinfo subdir for reading.&#10;&#10;Uses the pkg_resources module if available and no standard file&#10;found at the calculated location." ilk="function" line="79" lineend="96" name="open_resource" returns="open()" signature="open_resource(name)"><variable ilk="argument" line="79" name="name" /><variable line="85" name="name_parts" /><variable line="86" name="part" /><variable citdl="os.path.join()" line="89" name="filename" /></scope><scope doc="Return true if the given resource exists" ilk="function" line="99" lineend="105" name="resource_exists" returns="bool" signature="resource_exists(name)"><variable ilk="argument" line="99" name="name" /></scope><variable attributes="protected" citdl="dict" line="123" name="_tzinfo_cache" /><scope doc="Return a datetime.tzinfo implementation for the given timezone&#10;&#10;&gt;&gt;&gt; from datetime import datetime, timedelta&#10;&gt;&gt;&gt; utc = timezone('UTC')&#10;&gt;&gt;&gt; eastern = timezone('US/Eastern')&#10;&gt;&gt;&gt; eastern.zone&#10;'US/Eastern'&#10;&gt;&gt;&gt; timezone(str('US/Eastern')) is eastern&#10;True&#10;&gt;&gt;&gt; utc_dt = datetime(2002, 10, 27, 6, 0, 0, tzinfo=utc)&#10;&gt;&gt;&gt; loc_dt = utc_dt.astimezone(eastern)&#10;&gt;&gt;&gt; fmt = '%Y-%m-%d %H:%M:%S %Z (%z)'&#10;&gt;&gt;&gt; loc_dt.strftime(fmt)&#10;'2002-10-27 0o1:0o0:0o0 EST (-0o500)'&#10;&gt;&gt;&gt; (loc_dt - timedelta(minutes=10)).strftime(fmt)&#10;'2002-10-27 0o0:50:0o0 EST (-0o500)'&#10;&gt;&gt;&gt; eastern.normalize(loc_dt - timedelta(minutes=10)).strftime(fmt)&#10;'2002-10-27 0o1:50:0o0 EDT (-0o400)'&#10;&gt;&gt;&gt; (loc_dt + timedelta(minutes=10)).strftime(fmt)&#10;'2002-10-27 0o1:10:0o0 EST (-0o500)'&#10;&#10;Raises UnknownTimeZoneError if passed an unknown zone.&#10;&#10;&gt;&gt;&gt; try:&#10;...     timezone('Asia/Shangri-La')&#10;... except UnknownTimeZoneError:&#10;...     print('Unknown')&#10;Unknown&#10;&#10;&gt;&gt;&gt; try:&#10;...     timezone(str('\N{TRADE MARK SIGN}'))&#10;... except UnknownTimeZoneError:&#10;...     print('Unknown')&#10;Unknown" ilk="function" line="125" lineend="182" name="timezone" returns="utc" signature="timezone(zone)"><variable citdl="_unmunge_zone()" ilk="argument" line="125" name="zone" /><variable citdl="open_resource()" line="174" name="fp" /></scope><scope attributes="protected" doc="Undo the time zone name munging done by older versions of pytz." ilk="function" line="185" lineend="187" name="_unmunge_zone" signature="_unmunge_zone(zone)"><variable ilk="argument" line="185" name="zone" /></scope><variable citdl="datetime.timedelta()" line="190" name="ZERO" /><variable citdl="datetime.timedelta()" line="191" name="HOUR" /><variable citdl="UTC" doc="UTC&#10;&#10;Optimized UTC implementation. It unpickles using the single module global&#10;instance defined beneath this class declaration." line="194" name="UTC" /><scope attributes="protected" doc="Factory function for utc unpickling.&#10;&#10;Makes sure that unpickling a utc instance always returns the same&#10;module global.&#10;&#10;These examples belong in the UTC class above, but it is obscured; or in&#10;the README.txt, but we are not depending on Python 2.4 so integrating&#10;the README.txt examples with the unit tests is not trivial.&#10;&#10;&gt;&gt;&gt; import datetime, pickle&#10;&gt;&gt;&gt; dt = datetime.datetime(2005, 3, 1, 14, 13, 21, tzinfo=utc)&#10;&gt;&gt;&gt; naive = dt.replace(tzinfo=None)&#10;&gt;&gt;&gt; p = pickle.dumps(dt, 1)&#10;&gt;&gt;&gt; naive_p = pickle.dumps(naive, 1)&#10;&gt;&gt;&gt; len(p) - len(naive_p)&#10;17&#10;&gt;&gt;&gt; new = pickle.loads(p)&#10;&gt;&gt;&gt; new == dt&#10;True&#10;&gt;&gt;&gt; new is dt&#10;False&#10;&gt;&gt;&gt; new.tzinfo is dt.tzinfo&#10;True&#10;&gt;&gt;&gt; utc is UTC is timezone('UTC')&#10;True&#10;&gt;&gt;&gt; utc is timezone('GMT')&#10;False" ilk="function" line="247" lineend="276" name="_UTC" returns="utc" signature="_UTC()"><variable citdl="True" line="277" name="__safe_for_unpickling__" /></scope><scope attributes="protected" doc="Factory function for unpickling pytz tzinfo instances.&#10;&#10;Just a wrapper around tzinfo.unpickler to save a few bytes in each pickle&#10;by shortening the path." ilk="function" line="280" lineend="286" name="_p" returns="unpickler()" signature="_p()"><variable citdl="True" line="287" name="__safe_for_unpickling__" /></scope><scope attributes="protected" classrefs="LazyDict" doc="Map ISO 3166 country code to a list of timezone names commonly used&#10;in that country.&#10;&#10;iso3166_code is the two letter code used to identify the country.&#10;&#10;&gt;&gt;&gt; def print_list(list_of_strings):&#10;...     'We use a helper so doctests work under Python 2.3 -&gt; 3.x'&#10;...     for s in list_of_strings:&#10;...         print(s)&#10;&#10;&gt;&gt;&gt; print_list(country_timezones['nz'])&#10;Pacific/Auckland&#10;Pacific/Chatham&#10;&gt;&gt;&gt; print_list(country_timezones['ch'])&#10;Europe/Zurich&#10;&gt;&gt;&gt; print_list(country_timezones['CH'])&#10;Europe/Zurich&#10;&gt;&gt;&gt; print_list(country_timezones[str('ch')])&#10;Europe/Zurich&#10;&gt;&gt;&gt; print_list(country_timezones['XXX'])&#10;Traceback (most recent call last):&#10;...&#10;KeyError: 'XXX'&#10;&#10;Previously, this information was exposed as a function rather than a&#10;dictionary. This is still supported::&#10;&#10;&gt;&gt;&gt; print_list(country_timezones('nz'))&#10;Pacific/Auckland&#10;Pacific/Chatham" ilk="class" line="291" lineend="344" name="_CountryTimezoneDict"><scope doc="Backwards compatibility." ilk="function" line="323" lineend="325" name="__call__" signature="__call__(iso3166_code)"><variable citdl="_CountryTimezoneDict" ilk="argument" line="323" name="self" /><variable ilk="argument" line="323" name="iso3166_code" /></scope><scope attributes="protected" ilk="function" line="327" lineend="344" name="_fill" signature="_fill()"><variable citdl="_CountryTimezoneDict" ilk="argument" line="327" name="self" /><variable citdl="dict" line="328" name="data" /><variable citdl="open_resource()" line="329" name="zone_tab" /><variable citdl="line.decode()" line="331" name="line" /></scope><variable attributes="__instancevar__" citdl="dict" line="342" name="data" /></scope><variable citdl="_CountryTimezoneDict" line="346" name="country_timezones" /><scope attributes="protected" classrefs="LazyDict" doc="Dictionary proving ISO3166 code -&gt; English name.&#10;&#10;&gt;&gt;&gt; print(country_names['au'])&#10;Australia" ilk="class" line="349" lineend="367" name="_CountryNameDict"><scope attributes="protected" ilk="function" line="355" lineend="367" name="_fill" signature="_fill()"><variable citdl="_CountryNameDict" ilk="argument" line="355" name="self" /><variable citdl="dict" line="356" name="data" /><variable citdl="open_resource()" line="357" name="zone_tab" /><variable citdl="line.decode()" line="359" name="line" /><variable line="363" name="name" /><variable line="363" name="code" /></scope><variable attributes="__instancevar__" citdl="dict" line="365" name="data" /></scope><variable citdl="_CountryNameDict" line="369" name="country_names" /><scope attributes="protected" classrefs="datetime.tzinfo" ilk="class" line="374" lineend="409" name="_FixedOffset"><variable line="376" name="zone" /><scope attributes="__ctor__" ilk="function" line="378" lineend="382" name="__init__" signature="_FixedOffset(minutes)"><variable citdl="_FixedOffset" ilk="argument" line="378" name="self" /><variable ilk="argument" line="378" name="minutes" /></scope><variable attributes="protected __instancevar__" line="381" name="_minutes" /><variable attributes="protected __instancevar__" citdl="datetime.timedelta()" line="382" name="_offset" /><scope ilk="function" line="384" lineend="385" name="utcoffset" returns="datetime.timedelta()" signature="utcoffset(dt)"><variable citdl="_FixedOffset" ilk="argument" line="384" name="self" /><variable ilk="argument" line="384" name="dt" /></scope><scope ilk="function" line="387" lineend="388" name="__reduce__" returns="tuple" signature="__reduce__()"><variable citdl="_FixedOffset" ilk="argument" line="387" name="self" /></scope><scope ilk="function" line="390" lineend="391" name="dst" returns="datetime.timedelta()" signature="dst(dt)"><variable citdl="_FixedOffset" ilk="argument" line="390" name="self" /><variable ilk="argument" line="390" name="dt" /></scope><scope ilk="function" line="393" lineend="394" name="tzname" signature="tzname(dt)"><variable citdl="_FixedOffset" ilk="argument" line="393" name="self" /><variable ilk="argument" line="393" name="dt" /></scope><scope ilk="function" line="396" lineend="397" name="__repr__" signature="__repr__()"><variable citdl="_FixedOffset" ilk="argument" line="396" name="self" /></scope><scope doc="Convert naive time to local time" ilk="function" line="399" lineend="403" name="localize" returns="dt.replace()" signature="localize(dt, is_dst=False)"><variable citdl="_FixedOffset" ilk="argument" line="399" name="self" /><variable ilk="argument" line="399" name="dt" /><variable citdl="False" ilk="argument" line="399" name="is_dst" /></scope><scope doc="Correct the timezone information on the given datetime" ilk="function" line="405" lineend="409" name="normalize" returns="dt.replace()" signature="normalize(dt, is_dst=False)"><variable citdl="_FixedOffset" ilk="argument" line="405" name="self" /><variable ilk="argument" line="405" name="dt" /><variable citdl="False" ilk="argument" line="405" name="is_dst" /></scope></scope><scope doc="return a fixed-offset timezone based off a number of minutes.&#10;&#10;    &gt;&gt;&gt; one = FixedOffset(-330)&#10;    &gt;&gt;&gt; one&#10;    pytz.FixedOffset(-330)&#10;    &gt;&gt;&gt; one.utcoffset(datetime.datetime.now())&#10;    datetime.timedelta(-1, 66600)&#10;    &gt;&gt;&gt; one.dst(datetime.datetime.now())&#10;    datetime.timedelta(0)&#10;&#10;    &gt;&gt;&gt; two = FixedOffset(1380)&#10;    &gt;&gt;&gt; two&#10;    pytz.FixedOffset(1380)&#10;    &gt;&gt;&gt; two.utcoffset(datetime.datetime.now())&#10;    datetime.timedelta(0, 82800)&#10;    &gt;&gt;&gt; two.dst(datetime.datetime.now())&#10;    datetime.timedelta(0)&#10;&#10;The datetime.timedelta must be between the range of -1 and 1 day,&#10;non-inclusive.&#10;&#10;    &gt;&gt;&gt; FixedOffset(1440)&#10;    Traceback (most recent call last):&#10;    ...&#10;    ValueError: ('absolute offset is too large', 1440)&#10;&#10;    &gt;&gt;&gt; FixedOffset(-1440)&#10;    Traceback (most recent call last):&#10;    ...&#10;    ValueError: ('absolute offset is too large', -1440)&#10;&#10;An offset of 0 is special-cased to return UTC.&#10;&#10;    &gt;&gt;&gt; FixedOffset(0) is UTC&#10;    True&#10;&#10;There should always be only one instance of a FixedOffset per timedelta.&#10;This should be true for multiple creation calls.&#10;&#10;    &gt;&gt;&gt; FixedOffset(-330) is one&#10;    True&#10;    &gt;&gt;&gt; FixedOffset(1380) is two&#10;    True&#10;&#10;It should also be true for pickling.&#10;&#10;    &gt;&gt;&gt; import pickle&#10;    &gt;&gt;&gt; pickle.loads(pickle.dumps(one)) is one&#10;    True&#10;    &gt;&gt;&gt; pickle.loads(pickle.dumps(two)) is two&#10;    True" ilk="function" line="412" lineend="476" name="FixedOffset" returns="UTC" signature="FixedOffset(offset, _tzinfos={})"><variable ilk="argument" line="412" name="offset" /><variable citdl="dict" ilk="argument" line="412" name="_tzinfos" /><variable citdl="_tzinfos.setdefault()" line="468" name="info" /><variable citdl="True" line="478" name="__safe_for_unpickling__" /></scope><scope attributes="protected" ilk="function" line="481" lineend="485" name="_test" returns="doctest.testmod()" signature="_test()"><import line="482" module="doctest" /><import line="482" module="os" /><import line="482" module="sys" /><import line="484" module="pytz" /></scope><variable citdl="LazyList()" line="490" name="all_timezones" /><variable citdl="LazySet()" line="1080" name="all_timezones_set" /><variable citdl="LazyList()" line="1081" name="common_timezones" /><variable citdl="LazySet()" line="1519" name="common_timezones_set" /></scope>