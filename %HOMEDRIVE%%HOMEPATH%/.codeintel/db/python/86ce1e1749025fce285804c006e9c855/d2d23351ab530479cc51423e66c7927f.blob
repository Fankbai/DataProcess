<scope ilk="blob" lang="Python" name="pyparsing" src="d:\Program Files (x86)\Python35-32\lib\site-packages\pyparsing.py"><import line="64" module="string" /><import alias="wkref" line="65" module="weakref" symbol="ref" /><import line="66" module="copy" /><import line="67" module="sys" /><import line="68" module="warnings" /><import line="69" module="re" /><import line="70" module="sre_constants" /><import line="71" module="collections" /><import line="72" module="pprint" /><import line="73" module="functools" /><import line="74" module="itertools" /><import line="75" module="traceback" /><import line="135" module="__builtin__" /><variable citdl="str" line="25" name="__doc__" /><variable citdl="str" line="60" name="__version__" /><variable citdl="str" line="61" name="__versionTime__" /><variable citdl="str" line="62" name="__author__" /><variable citdl="list" line="79" name="__all__" /><variable citdl="sys.version.startswith()" line="99" name="PY_3" /><variable attributes="protected" citdl="sys.maxsize" line="101" name="_MAX_INT" /><variable line="102" name="str" /><variable citdl="chr" line="103" name="unichr" /><variable citdl="list" line="107" name="singleArgBuiltins" /><variable citdl="xrange" line="111" name="range" /><scope attributes="protected" doc="Drop-in replacement for str(obj) that tries to be Unicode friendly. It first tries&#10;str(obj). If that fails with a UnicodeEncodeError, then it tries str(obj). It&#10;then &lt; returns the str object | encodes it with the default encoding | ... &gt;." ilk="function" line="113" lineend="131" name="_ustr" returns="str()" signature="_ustr(obj)"><variable ilk="argument" line="113" name="obj" /><variable line="128" name="ret" /><variable citdl="Regex()" line="129" name="xmlcharref" /></scope><variable line="136" name="fname" /><variable attributes="protected" citdl="type()" line="142" name="_generatorType" /><scope attributes="protected" doc="Escape &amp;, &lt;, &gt;, &quot;, ', etc. in a string of data." ilk="function" line="144" lineend="152" name="_xml_escape" returns="data.replace()" signature="_xml_escape(data)"><variable citdl="data.replace()" ilk="argument" line="144" name="data" /><variable citdl="str" line="148" name="from_symbols" /><variable line="149" name="to_symbols" /><variable line="150" name="from_" /><variable line="150" name="to_" /></scope><scope attributes="protected" classrefs="object" ilk="class" line="154" lineend="155" name="_Constants" /><variable line="157" name="alphas" /><variable citdl="str" line="158" name="nums" /><variable line="159" name="hexnums" /><variable line="160" name="alphanums" /><variable attributes="protected" citdl="chr()" line="161" name="_bslash" /><variable citdl="__builtins__.str.join()" line="162" name="printables" /><scope classrefs="Exception" doc="base exception class for all parsing runtime exceptions" ilk="class" line="164" lineend="209" name="ParseBaseException"><scope attributes="__ctor__" ilk="function" line="168" lineend="176" name="__init__" signature="ParseBaseException(pstr, loc=0, msg=None, elem=None)"><variable citdl="ParseBaseException" ilk="argument" line="168" name="self" /><variable ilk="argument" line="168" name="pstr" /><variable citdl="int" ilk="argument" line="168" name="loc" /><variable ilk="argument" line="168" name="msg" /><variable ilk="argument" line="168" name="elem" /></scope><variable attributes="__instancevar__" citdl="int" line="169" name="loc" /><variable attributes="__instancevar__" line="171" name="msg" /><variable attributes="__instancevar__" citdl="str" line="172" name="pstr" /><variable attributes="__instancevar__" line="176" name="parserElement" /><scope doc="supported attributes by name are:&#10;- lineno - returns the line number of the exception text&#10;- col - returns the column number of the exception text&#10;- line - returns the line containing the exception text" ilk="function" line="178" lineend="191" name="__getattr__" returns="lineno()" signature="__getattr__(aname)"><variable citdl="ParseBaseException" ilk="argument" line="178" name="self" /><variable ilk="argument" line="178" name="aname" /></scope><scope ilk="function" line="193" lineend="195" name="__str__" signature="__str__()"><variable citdl="ParseBaseException" ilk="argument" line="193" name="self" /></scope><scope ilk="function" line="196" lineend="197" name="__repr__" returns="_ustr()" signature="__repr__()"><variable citdl="ParseBaseException" ilk="argument" line="196" name="self" /></scope><scope doc="Extracts the exception line from the input string, and marks&#10;the location of the exception with a special symbol." ilk="function" line="198" lineend="207" name="markInputline" returns="line_str.strip()" signature="markInputline(markerString='&gt;!&lt;')"><variable citdl="ParseBaseException" ilk="argument" line="198" name="self" /><variable citdl="str" ilk="argument" line="198" name="markerString" /><variable citdl="self.line" line="202" name="line_str" /><variable line="203" name="line_column" /></scope><scope ilk="function" line="208" lineend="209" name="__dir__" signature="__dir__()"><variable citdl="ParseBaseException" ilk="argument" line="208" name="self" /></scope></scope><scope classrefs="ParseBaseException" doc="exception thrown when parse expressions don't match class;&#10;supported attributes by name are:&#10; - lineno - returns the line number of the exception text&#10; - col - returns the column number of the exception text&#10; - line - returns the line containing the exception text" ilk="class" line="211" lineend="218" name="ParseException" /><scope classrefs="ParseBaseException" doc="user-throwable exception thrown when inconsistent parse content&#10;is found; stops all parsing immediately" ilk="class" line="220" lineend="223" name="ParseFatalException" /><scope classrefs="ParseFatalException" doc="just like C{L{ParseFatalException}}, but thrown internally when an&#10;C{L{ErrorStop&lt;And._ErrorStop&gt;}} ('-' operator) indicates that parsing is to stop immediately because&#10;an unbacktrackable syntax error has been found" ilk="class" line="225" lineend="231" name="ParseSyntaxException"><scope attributes="__ctor__" ilk="function" line="229" lineend="231" name="__init__" signature="ParseSyntaxException(pe)"><variable citdl="ParseSyntaxException" ilk="argument" line="229" name="self" /><variable ilk="argument" line="229" name="pe" /></scope></scope><scope classrefs="Exception" doc="exception thrown by C{validate()} if the grammar could be improperly recursive" ilk="class" line="246" lineend="252" name="RecursiveGrammarException"><scope attributes="__ctor__" ilk="function" line="248" lineend="249" name="__init__" signature="RecursiveGrammarException(parseElementList)"><variable citdl="RecursiveGrammarException" ilk="argument" line="248" name="self" /><variable ilk="argument" line="248" name="parseElementList" /></scope><variable attributes="__instancevar__" line="249" name="parseElementTrace" /><scope ilk="function" line="251" lineend="252" name="__str__" signature="__str__()"><variable citdl="RecursiveGrammarException" ilk="argument" line="251" name="self" /></scope></scope><scope attributes="protected" classrefs="object" ilk="class" line="254" lineend="262" name="_ParseResultsWithOffset"><scope attributes="__ctor__" ilk="function" line="255" lineend="256" name="__init__" signature="_ParseResultsWithOffset(p1, p2)"><variable citdl="_ParseResultsWithOffset" ilk="argument" line="255" name="self" /><variable ilk="argument" line="255" name="p1" /><variable ilk="argument" line="255" name="p2" /></scope><variable attributes="__instancevar__" citdl="tuple" line="256" name="tup" /><scope ilk="function" line="257" lineend="258" name="__getitem__" signature="__getitem__(i)"><variable citdl="_ParseResultsWithOffset" ilk="argument" line="257" name="self" /><variable ilk="argument" line="257" name="i" /></scope><scope ilk="function" line="259" lineend="260" name="__repr__" returns="repr()" signature="__repr__()"><variable citdl="_ParseResultsWithOffset" ilk="argument" line="259" name="self" /></scope><scope ilk="function" line="261" lineend="262" name="setOffset" signature="setOffset(i)"><variable citdl="_ParseResultsWithOffset" ilk="argument" line="261" name="self" /><variable ilk="argument" line="261" name="i" /></scope></scope><scope classrefs="object" doc="Structured parse results, to provide multiple means of access to the parsed data:&#10;- as a list (C{len(results)})&#10;- by list index (C{results[0], results[1]}, etc.)&#10;- by attribute (C{results.&lt;resultsName&gt;})" ilk="class" line="264" lineend="699" name="ParseResults"><scope ilk="function" line="270" lineend="275" name="__new__" returns="object.__new__()" signature="__new__(toklist=None, name=None, asList=True, modal=True)"><variable citdl="ParseResults" ilk="argument" line="270" name="cls" /><variable ilk="argument" line="270" name="toklist" /><variable ilk="argument" line="270" name="name" /><variable citdl="True" ilk="argument" line="270" name="asList" /><variable citdl="True" ilk="argument" line="270" name="modal" /><variable citdl="object.__new__()" line="273" name="retobj" /></scope><scope attributes="__ctor__" ilk="function" line="279" lineend="316" name="__init__" signature="ParseResults(toklist=None, name=None, asList=True, modal=True, isinstance=isinstance)"><variable citdl="ParseResults" ilk="argument" line="279" name="self" /><variable citdl="list" ilk="argument" line="279" name="toklist" /><variable citdl="_ustr()" ilk="argument" line="279" name="name" /><variable citdl="True" ilk="argument" line="279" name="asList" /><variable citdl="True" ilk="argument" line="279" name="modal" /><variable citdl="isinstance" ilk="argument" line="279" name="isinstance" /></scope><variable attributes="private __instancevar__" citdl="False" line="281" name="__doinit" /><variable attributes="private __instancevar__" citdl="_ustr()" line="282" name="__name" /><variable attributes="private __instancevar__" citdl="wkref()" line="283" name="__parent" /><variable attributes="private __instancevar__" citdl="dict" line="284" name="__accumNames" /><variable attributes="private __instancevar__" citdl="True" line="285" name="__asList" /><variable attributes="private __instancevar__" citdl="True" line="286" name="__modal" /><variable attributes="private __instancevar__" citdl="list" line="290" name="__toklist" /><variable attributes="private __instancevar__" citdl="dict()" line="295" name="__tokdict" /><scope ilk="function" line="318" lineend="325" name="__getitem__" returns="ParseResults" signature="__getitem__(i)"><variable citdl="ParseResults" ilk="argument" line="318" name="self" /><variable ilk="argument" line="318" name="i" /></scope><scope ilk="function" line="327" lineend="338" name="__setitem__" signature="__setitem__(k, v, isinstance=isinstance)"><variable citdl="ParseResults" ilk="argument" line="327" name="self" /><variable ilk="argument" line="327" name="k" /><variable ilk="argument" line="327" name="v" /><variable citdl="isinstance" ilk="argument" line="327" name="isinstance" /><variable line="330" name="sub" /></scope><scope ilk="function" line="340" lineend="364" name="__delitem__" signature="__delitem__(i)"><variable citdl="ParseResults" ilk="argument" line="340" name="self" /><variable citdl="slice()" ilk="argument" line="340" name="i" /><variable citdl="len()" line="342" name="mylen" /><variable citdl="list()" line="351" name="removed" /><variable line="359" name="name" /><variable line="359" name="occurrences" /><variable line="360" name="j" /><variable line="361" name="k" /></scope><scope ilk="function" line="366" lineend="367" name="__contains__" returns="bool" signature="__contains__(k)"><variable citdl="ParseResults" ilk="argument" line="366" name="self" /><variable ilk="argument" line="366" name="k" /></scope><scope ilk="function" line="369" lineend="369" name="__len__" returns="len()" signature="__len__()"><variable citdl="ParseResults" ilk="argument" line="369" name="self" /></scope><scope ilk="function" line="370" lineend="370" name="__bool__" returns="list()" signature="__bool__()"><variable citdl="ParseResults" ilk="argument" line="370" name="self" /></scope><variable citdl="ParseResults.__bool__" line="371" name="__nonzero__" /><scope ilk="function" line="372" lineend="372" name="__iter__" returns="iter()" signature="__iter__()"><variable citdl="ParseResults" ilk="argument" line="372" name="self" /></scope><scope ilk="function" line="373" lineend="373" name="__reversed__" returns="iter()" signature="__reversed__()"><variable citdl="ParseResults" ilk="argument" line="373" name="self" /></scope><scope doc="Returns all named result keys." ilk="function" line="374" lineend="379" name="iterkeys" returns="self.__tokdict.iterkeys()" signature="iterkeys()"><variable citdl="ParseResults" ilk="argument" line="374" name="self" /></scope><scope doc="Returns all named result values." ilk="function" line="381" lineend="383" name="itervalues" signature="itervalues()"><variable citdl="ParseResults" ilk="argument" line="381" name="self" /></scope><scope ilk="function" line="385" lineend="386" name="iteritems" signature="iteritems()"><variable citdl="ParseResults" ilk="argument" line="385" name="self" /></scope><scope doc="Returns all named result keys." ilk="function" line="393" lineend="395" name="keys" returns="list()" signature="keys()"><variable citdl="ParseResults" ilk="argument" line="393" name="self" /></scope><scope doc="Returns all named result values." ilk="function" line="397" lineend="399" name="values" returns="list()" signature="values()"><variable citdl="ParseResults" ilk="argument" line="397" name="self" /></scope><scope doc="Returns all named result keys and values as a list of tuples." ilk="function" line="401" lineend="403" name="items" returns="list()" signature="items()"><variable citdl="ParseResults" ilk="argument" line="401" name="self" /></scope><scope doc="Since keys() returns an iterator, this method is helpful in bypassing&#10;code that looks for the existence of any defined results names." ilk="function" line="405" lineend="408" name="haskeys" returns="bool()" signature="haskeys()"><variable citdl="ParseResults" ilk="argument" line="405" name="self" /></scope><scope doc="Removes and returns item at specified index (default=last).&#10;Supports both list and dict semantics for pop(). If passed no&#10;argument or an integer argument, it will use list semantics&#10;and pop tokens from the list of parsed tokens. If passed a &#10;non-integer argument (most likely a string), it will use dict&#10;semantics and pop the corresponding value from any defined &#10;results names. A second default return value argument is &#10;supported, just as in dict.pop()." ilk="function" line="410" lineend="435" name="pop" signature="pop()"><variable attributes="kwargs" citdl="ParseResults" ilk="argument" line="410" name="self" /><variable citdl="tuple" line="420" name="args" /><variable line="421" name="k" /><variable line="421" name="v" /><variable line="429" name="index" /><variable line="430" name="ret" /><variable line="434" name="defaultvalue" /></scope><scope doc="Returns named result matching the given key, or if there is no&#10;such name, then returns the given C{defaultValue} or C{None} if no&#10;C{defaultValue} is specified." ilk="function" line="437" lineend="444" name="get" signature="get(key, defaultValue=None)"><variable citdl="ParseResults" ilk="argument" line="437" name="self" /><variable ilk="argument" line="437" name="key" /><variable ilk="argument" line="437" name="defaultValue" /></scope><scope doc="Inserts new element at location index in the list of parsed tokens." ilk="function" line="446" lineend="456" name="insert" signature="insert(index, insStr)"><variable citdl="ParseResults" ilk="argument" line="446" name="self" /><variable ilk="argument" line="446" name="index" /><variable ilk="argument" line="446" name="insStr" /><variable line="454" name="name" /><variable line="454" name="occurrences" /><variable line="455" name="k" /></scope><scope doc="Add single element to end of ParseResults list of elements." ilk="function" line="458" lineend="460" name="append" signature="append(item)"><variable citdl="ParseResults" ilk="argument" line="458" name="self" /><variable ilk="argument" line="458" name="item" /></scope><scope doc="Add sequence of elements to end of ParseResults list of elements." ilk="function" line="462" lineend="467" name="extend" signature="extend(itemseq)"><variable citdl="ParseResults" ilk="argument" line="462" name="self" /><variable ilk="argument" line="462" name="itemseq" /></scope><scope doc="Clear all elements and results names." ilk="function" line="469" lineend="472" name="clear" signature="clear()"><variable citdl="ParseResults" ilk="argument" line="469" name="self" /></scope><scope ilk="function" line="474" lineend="486" name="__getattr__" returns="ParseResults" signature="__getattr__(name)"><variable citdl="ParseResults" ilk="argument" line="474" name="self" /><variable ilk="argument" line="474" name="name" /></scope><scope ilk="function" line="488" lineend="491" name="__add__" returns="self.copy()" signature="__add__(other)"><variable citdl="ParseResults" ilk="argument" line="488" name="self" /><variable ilk="argument" line="488" name="other" /><variable citdl="self.copy()" line="489" name="ret" /></scope><scope ilk="function" line="493" lineend="507" name="__iadd__" returns="ParseResults" signature="__iadd__(other)"><variable citdl="ParseResults" ilk="argument" line="493" name="self" /><variable ilk="argument" line="493" name="other" /><variable citdl="len()" line="495" name="offset" /><variable line="496" name="addoffset" /><variable citdl="other.__tokdict.items()" line="497" name="otheritems" /><variable citdl="list" line="498" name="otherdictitems" /><variable line="500" name="v" /><variable line="500" name="k" /></scope><scope ilk="function" line="509" lineend="515" name="__radd__" returns="self.copy()" signature="__radd__(other)"><variable citdl="ParseResults" ilk="argument" line="509" name="self" /><variable ilk="argument" line="509" name="other" /></scope><scope ilk="function" line="517" lineend="518" name="__repr__" signature="__repr__()"><variable citdl="ParseResults" ilk="argument" line="517" name="self" /></scope><scope ilk="function" line="520" lineend="521" name="__str__" signature="__str__()"><variable citdl="ParseResults" ilk="argument" line="520" name="self" /></scope><scope attributes="protected" ilk="function" line="523" lineend="532" name="_asStringList" returns="list" signature="_asStringList(sep='')"><variable citdl="ParseResults" ilk="argument" line="523" name="self" /><variable citdl="str" ilk="argument" line="523" name="sep" /><variable citdl="list" line="524" name="out" /><variable line="525" name="item" /></scope><scope doc="Returns the parse results as a nested list of matching tokens, all converted to strings." ilk="function" line="534" lineend="536" name="asList" returns="list" signature="asList()"><variable citdl="ParseResults" ilk="argument" line="534" name="self" /></scope><scope doc="Returns the named parse results as a nested dictionary." ilk="function" line="538" lineend="544" name="asDict" returns="dict()" signature="asDict()"><variable citdl="ParseResults" ilk="argument" line="538" name="self" /><variable citdl="ParseResults.items" line="541" name="item_fn" /></scope><scope doc="Returns a new copy of a C{ParseResults} object." ilk="function" line="546" lineend="553" name="copy" signature="copy()"><variable citdl="ParseResults" ilk="argument" line="546" name="self" /><variable citdl="" line="548" name="ret" /></scope><scope doc="Returns the parse results as XML. Tags are created for tokens and lists that have defined results names." ilk="function" line="555" lineend="612" name="asXML" returns="__builtins__.str.join()" signature="asXML(doctag=None, namedItemsOnly=False, indent='', formatted=True)"><variable citdl="ParseResults" ilk="argument" line="555" name="self" /><variable ilk="argument" line="555" name="doctag" /><variable citdl="False" ilk="argument" line="555" name="namedItemsOnly" /><variable citdl="str" ilk="argument" line="555" name="indent" /><variable citdl="True" ilk="argument" line="555" name="formatted" /><variable citdl="str" line="557" name="nl" /><variable citdl="list" line="558" name="out" /><variable citdl="dict()" line="559" name="namedItems" /><variable citdl="str" line="561" name="nextLevelIndent" /><variable citdl="str" line="569" name="selfTag" /><variable line="584" name="res" /><variable line="584" name="i" /><variable citdl="str" line="598" name="resTag" /><variable citdl="_xml_escape()" line="606" name="xmlBodyText" /></scope><scope attributes="private" ilk="function" line="614" lineend="619" name="__lookup" signature="__lookup(sub)"><variable citdl="ParseResults" ilk="argument" line="614" name="self" /><variable ilk="argument" line="614" name="sub" /><variable line="615" name="vlist" /><variable line="615" name="k" /><variable line="616" name="v" /><variable line="616" name="loc" /></scope><scope doc="Returns the results name for this token expression." ilk="function" line="621" lineend="636" name="getName" returns="_ustr()" signature="getName()"><variable citdl="ParseResults" ilk="argument" line="621" name="self" /><variable citdl="__parent()" line="626" name="par" /></scope><scope doc="Diagnostic method for listing out the contents of a C{ParseResults}.&#10;Accepts an optional C{indent} argument so that this string can be embedded&#10;in a nested display of other data." ilk="function" line="638" lineend="666" name="dump" returns="__builtins__.str.join()" signature="dump(indent='', depth=0)"><variable citdl="ParseResults" ilk="argument" line="638" name="self" /><variable citdl="str" ilk="argument" line="638" name="indent" /><variable citdl="int" ilk="argument" line="638" name="depth" /><variable citdl="list" line="642" name="out" /><variable citdl="str" line="643" name="NL" /><variable citdl="sorted()" line="646" name="items" /><variable line="647" name="k" /><variable citdl="ParseResults" line="647" name="v" /><variable line="660" name="i" /><variable line="660" name="vv" /></scope><scope doc="Pretty-printer for parsed results as a list, using the C{pprint} module.&#10;Accepts additional positional or keyword args as defined for the &#10;C{pprint.pprint} method. (U{http://docs.python.org/3/library/pprint.html#pprint.pprint})" ilk="function" line="668" lineend="672" name="pprint" signature="pprint()"><variable attributes="kwargs" citdl="ParseResults" ilk="argument" line="668" name="self" /></scope><scope ilk="function" line="675" lineend="676" name="__getstate__" returns="tuple" signature="__getstate__()"><variable citdl="ParseResults" ilk="argument" line="675" name="self" /></scope><scope ilk="function" line="682" lineend="693" name="__setstate__" signature="__setstate__(state)"><variable citdl="ParseResults" ilk="argument" line="682" name="self" /><variable ilk="argument" line="682" name="state" /></scope><scope ilk="function" line="695" lineend="696" name="__getnewargs__" returns="tuple" signature="__getnewargs__()"><variable citdl="ParseResults" ilk="argument" line="695" name="self" /></scope><scope ilk="function" line="698" lineend="699" name="__dir__" signature="__dir__()"><variable citdl="ParseResults" ilk="argument" line="698" name="self" /></scope></scope><scope doc="Returns current column within a string, counting newlines as line separators.&#10;The first column is number 1.&#10;&#10;Note: the default parsing behavior is to expand tabs in the input string&#10;before starting the parsing process.  See L{I{ParserElement.parseString}&lt;ParserElement.parseString&gt;} for more information&#10;on parsing strings containing C{&lt;TAB&gt;}s, and suggested methods to maintain a&#10;consistent view of the parsed string, the parse location, and line and column&#10;positions within the parsed string." ilk="function" line="703" lineend="714" name="col" signature="col(loc, strg)"><variable ilk="argument" line="703" name="loc" /><variable ilk="argument" line="703" name="strg" /><variable line="713" name="s" /></scope><scope doc="Returns current line number within a string, counting newlines as line separators.&#10;The first line is number 1.&#10;&#10;Note: the default parsing behavior is to expand tabs in the input string&#10;before starting the parsing process.  See L{I{ParserElement.parseString}&lt;ParserElement.parseString&gt;} for more information&#10;on parsing strings containing C{&lt;TAB&gt;}s, and suggested methods to maintain a&#10;consistent view of the parsed string, the parse location, and line and column&#10;positions within the parsed string." ilk="function" line="716" lineend="726" name="lineno" signature="lineno(loc, strg)"><variable ilk="argument" line="716" name="loc" /><variable ilk="argument" line="716" name="strg" /></scope><scope doc="Returns the line of text containing loc within a string, counting newlines as line separators.&#10;       " ilk="function" line="728" lineend="736" name="line" signature="line(loc, strg)"><variable ilk="argument" line="728" name="loc" /><variable ilk="argument" line="728" name="strg" /><variable citdl="strg.rfind()" line="731" name="lastCR" /><variable citdl="strg.find()" line="732" name="nextCR" /></scope><scope attributes="protected" ilk="function" line="738" lineend="739" name="_defaultStartDebugAction" signature="_defaultStartDebugAction(instring, loc, expr)"><variable ilk="argument" line="738" name="instring" /><variable ilk="argument" line="738" name="loc" /><variable ilk="argument" line="738" name="expr" /></scope><scope attributes="protected" ilk="function" line="741" lineend="742" name="_defaultSuccessDebugAction" signature="_defaultSuccessDebugAction(instring, startloc, endloc, expr, toks)"><variable ilk="argument" line="741" name="instring" /><variable ilk="argument" line="741" name="startloc" /><variable ilk="argument" line="741" name="endloc" /><variable ilk="argument" line="741" name="expr" /><variable ilk="argument" line="741" name="toks" /></scope><scope attributes="protected" ilk="function" line="744" lineend="745" name="_defaultExceptionDebugAction" signature="_defaultExceptionDebugAction(instring, loc, expr, exc)"><variable ilk="argument" line="744" name="instring" /><variable ilk="argument" line="744" name="loc" /><variable ilk="argument" line="744" name="expr" /><variable ilk="argument" line="744" name="exc" /></scope><scope doc="'Do-nothing' debug action, to suppress debugging output during parsing." ilk="function" line="747" lineend="749" name="nullDebugAction" signature="nullDebugAction()" /><scope attributes="protected" ilk="function" line="774" lineend="802" name="_trim_arity" returns="_trim_arity.wrapper" signature="_trim_arity(func, maxargs=2)"><variable ilk="argument" line="774" name="func" /><variable citdl="int" ilk="argument" line="774" name="maxargs" /><variable citdl="list" line="777" name="limit" /><variable citdl="list" line="778" name="foundArity" /><scope ilk="function" line="779" lineend="801" name="wrapper" returns="func()" signature="wrapper()"><variable citdl="func()" line="782" name="ret" /><variable line="791" name="tb" /><variable line="792" name="exc_source_line" /></scope></scope><scope classrefs="object" doc="Abstract base level parser element class." ilk="class" line="804" lineend="1600" name="ParserElement"><variable citdl="str" line="806" name="DEFAULT_WHITE_CHARS" /><variable citdl="False" line="807" name="verbose_stacktrace" /><scope attributes="__staticmethod__" doc="Overrides the default whitespace chars&#10;        " ilk="function" line="809" lineend="809" name="setDefaultWhitespaceChars" signature="setDefaultWhitespaceChars(chars) - staticmethod"><variable citdl="ParserElement" ilk="argument" line="809" name="chars" /></scope><scope attributes="__staticmethod__" doc="Set class to be used for inclusion of string literals into a parser." ilk="function" line="815" lineend="815" name="inlineLiteralsUsing" signature="inlineLiteralsUsing(cls) - staticmethod"><variable citdl="ParserElement" ilk="argument" line="815" name="cls" /></scope><variable attributes="__instancevar__" citdl="ParserElement" line="820" name="literalStringClass" /><scope attributes="__ctor__" ilk="function" line="822" lineend="843" name="__init__" signature="ParserElement(savelist=False)"><variable citdl="ParserElement" ilk="argument" line="822" name="self" /><variable citdl="False" ilk="argument" line="822" name="savelist" /></scope><variable attributes="__instancevar__" citdl="list()" line="823" name="parseAction" /><variable attributes="__instancevar__" line="824" name="failAction" /><variable attributes="__instancevar__" line="826" name="strRepr" /><variable attributes="__instancevar__" line="827" name="resultsName" /><variable attributes="__instancevar__" citdl="False" line="828" name="saveAsList" /><variable attributes="__instancevar__" citdl="True" line="829" name="skipWhitespace" /><variable attributes="__instancevar__" citdl="str" line="830" name="whiteChars" /><variable attributes="__instancevar__" citdl="True" line="831" name="copyDefaultWhiteChars" /><variable attributes="__instancevar__" citdl="False" line="832" name="mayReturnEmpty" /><variable attributes="__instancevar__" citdl="False" line="833" name="keepTabs" /><variable attributes="__instancevar__" citdl="list()" line="834" name="ignoreExprs" /><variable attributes="__instancevar__" citdl="False" line="835" name="debug" /><variable attributes="__instancevar__" citdl="False" line="836" name="streamlined" /><variable attributes="__instancevar__" citdl="True" line="837" name="mayIndexError" /><variable attributes="__instancevar__" citdl="str" line="838" name="errmsg" /><variable attributes="__instancevar__" citdl="True" line="839" name="modalResults" /><variable attributes="__instancevar__" citdl="tuple" line="840" name="debugActions" /><variable attributes="__instancevar__" line="841" name="re" /><variable attributes="__instancevar__" citdl="True" line="842" name="callPreparse" /><variable attributes="__instancevar__" citdl="kwargs.get()" line="843" name="callDuringTry" /><scope doc="Make a copy of this C{ParserElement}.  Useful for defining different parse actions&#10;for the same parsing pattern, using copies of the original parse element." ilk="function" line="845" lineend="853" name="copy" returns="copy.copy()" signature="copy()"><variable citdl="ParserElement" ilk="argument" line="845" name="self" /><variable citdl="copy.copy()" line="848" name="cpy" /></scope><scope doc="Define name for this expression, for use in debugging." ilk="function" line="855" lineend="861" name="setName" returns="ParserElement" signature="setName(name)"><variable citdl="ParserElement" ilk="argument" line="855" name="self" /><variable ilk="argument" line="855" name="name" /></scope><variable attributes="__instancevar__" line="857" name="name" /><scope doc="Define name for referencing matching tokens as a nested attribute&#10;of the returned parse results.&#10;NOTE: this returns a *copy* of the original C{ParserElement} object;&#10;this is so that the client can define a basic element, such as an&#10;integer, and reference it in multiple places with different names.&#10;&#10;You can also set results names using the abbreviated syntax,&#10;C{expr(&quot;name&quot;)} in place of C{expr.setResultsName(&quot;name&quot;)} - &#10;see L{I{__call__}&lt;__call__&gt;}." ilk="function" line="863" lineend="880" name="setResultsName" returns="copy()" signature="setResultsName(name, listAllMatches=False)"><variable citdl="ParserElement" ilk="argument" line="863" name="self" /><variable ilk="argument" line="863" name="name" /><variable citdl="True" ilk="argument" line="863" name="listAllMatches" /><variable citdl="copy()" line="874" name="newself" /></scope><scope doc="Method to invoke the Python pdb debugger when this element is&#10;about to be parsed. Set C{breakFlag} to True to enable, False to&#10;disable." ilk="function" line="882" lineend="898" name="setBreak" returns="ParserElement" signature="setBreak(breakFlag=True)"><variable citdl="ParserElement" ilk="argument" line="882" name="self" /><variable citdl="True" ilk="argument" line="882" name="breakFlag" /><variable attributes="protected" citdl="self._parse" line="888" name="_parseMethod" /><scope ilk="function" line="889" lineend="892" name="breaker" returns="ParserElement.setBreak._parseMethod()" signature="breaker(instring, loc, doActions=True, callPreParse=True)"><import line="890" module="pdb" /><variable ilk="argument" line="889" name="instring" /><variable ilk="argument" line="889" name="loc" /><variable citdl="True" ilk="argument" line="889" name="doActions" /><variable citdl="True" ilk="argument" line="889" name="callPreParse" /><variable attributes="protected" citdl="self._parse" line="893" name="_originalParseMethod" /></scope></scope><scope doc="Define action to perform when successfully matching parse element definition.&#10;Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},&#10;C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:&#10; - s   = the original string being parsed (see note below)&#10; - loc = the location of the matching substring&#10; - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object&#10;If the functions in fns modify the tokens, they can return them as the return&#10;value from fn, and the modified list of tokens will replace the original.&#10;Otherwise, fn does not need to return any value.&#10;&#10;Note: the default parsing behavior is to expand tabs in the input string&#10;before starting the parsing process.  See L{I{parseString}&lt;parseString&gt;} for more information&#10;on parsing strings containing C{&lt;TAB&gt;}s, and suggested methods to maintain a&#10;consistent view of the parsed string, the parse location, and line and column&#10;positions within the parsed string." ilk="function" line="900" lineend="919" name="setParseAction" returns="ParserElement" signature="setParseAction()"><variable attributes="kwargs" citdl="ParserElement" ilk="argument" line="900" name="self" /></scope><scope doc="Add parse action to expression's list of parse actions. See L{I{setParseAction}&lt;setParseAction&gt;}." ilk="function" line="921" lineend="925" name="addParseAction" returns="ParserElement" signature="addParseAction()"><variable attributes="kwargs" citdl="ParserElement" ilk="argument" line="921" name="self" /></scope><scope doc="Add a boolean predicate function to expression's list of parse actions. See &#10;L{I{setParseAction}&lt;setParseAction&gt;}. Optional keyword argument C{message} can&#10;be used to define a custom message to be used in the raised exception." ilk="function" line="927" lineend="939" name="addCondition" returns="ParserElement" signature="addCondition()"><variable attributes="kwargs" citdl="ParserElement" ilk="argument" line="927" name="self" /><variable citdl="str" line="931" name="msg" /><variable line="932" name="fn" /><scope ilk="function" line="933" lineend="936" name="pa" signature="pa(s, l, t)"><variable ilk="argument" line="933" name="s" /><variable ilk="argument" line="933" name="l" /><variable ilk="argument" line="933" name="t" /></scope></scope><scope doc="Define action to perform if parsing fails at this expression.&#10;Fail acton fn is a callable function that takes the arguments&#10;C{fn(s,loc,expr,err)} where:&#10; - s = string being parsed&#10; - loc = location where expression match was attempted and failed&#10; - expr = the parse expression that failed&#10; - err = the exception thrown&#10;The function returns no value.  It may throw C{L{ParseFatalException}}&#10;if it is desired to stop parsing immediately." ilk="function" line="941" lineend="952" name="setFailAction" returns="ParserElement" signature="setFailAction(fn)"><variable citdl="ParserElement" ilk="argument" line="941" name="self" /><variable ilk="argument" line="941" name="fn" /></scope><scope attributes="protected" ilk="function" line="954" lineend="965" name="_skipIgnorables" signature="_skipIgnorables(instring, loc)"><variable citdl="ParserElement" ilk="argument" line="954" name="self" /><variable ilk="argument" line="954" name="instring" /><variable ilk="argument" line="954" name="loc" /><variable citdl="True" line="955" name="exprsFound" /><variable line="958" name="e" /><variable line="961" name="dummy" /></scope><scope ilk="function" line="967" lineend="977" name="preParse" returns="_skipIgnorables()" signature="preParse(instring, loc)"><variable citdl="ParserElement" ilk="argument" line="967" name="self" /><variable ilk="argument" line="967" name="instring" /><variable citdl="_skipIgnorables()" ilk="argument" line="967" name="loc" /><variable citdl="str" line="972" name="wt" /><variable citdl="len()" line="973" name="instrlen" /></scope><scope ilk="function" line="979" lineend="980" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="ParserElement" ilk="argument" line="979" name="self" /><variable ilk="argument" line="979" name="instring" /><variable ilk="argument" line="979" name="loc" /><variable citdl="True" ilk="argument" line="979" name="doActions" /></scope><scope ilk="function" line="982" lineend="983" name="postParse" signature="postParse(instring, loc, tokenlist)"><variable citdl="ParserElement" ilk="argument" line="982" name="self" /><variable ilk="argument" line="982" name="instring" /><variable ilk="argument" line="982" name="loc" /><variable ilk="argument" line="982" name="tokenlist" /></scope><scope attributes="protected" ilk="function" line="986" lineend="1056" name="_parseNoCache" returns="tuple" signature="_parseNoCache(instring, loc, doActions=True, callPreParse=True)"><variable citdl="ParserElement" ilk="argument" line="986" name="self" /><variable ilk="argument" line="986" name="instring" /><variable ilk="argument" line="986" name="loc" /><variable citdl="True" ilk="argument" line="986" name="doActions" /><variable citdl="True" ilk="argument" line="986" name="callPreParse" /><variable citdl="False" line="987" name="debugging" /><variable citdl="preParse()" line="994" name="preloc" /><variable citdl="preParse()" line="997" name="tokensStart" /><variable citdl="fn()" line="1000" name="tokens" /><variable citdl="ParseResults" line="1026" name="retTokens" /><variable line="1030" name="fn" /></scope><scope ilk="function" line="1058" lineend="1062" name="tryParse" signature="tryParse(instring, loc)"><variable citdl="ParserElement" ilk="argument" line="1058" name="self" /><variable ilk="argument" line="1058" name="instring" /><variable ilk="argument" line="1058" name="loc" /></scope><scope ilk="function" line="1064" lineend="1070" name="canParseNext" returns="bool" signature="canParseNext(instring, loc)"><variable citdl="ParserElement" ilk="argument" line="1064" name="self" /><variable ilk="argument" line="1064" name="instring" /><variable ilk="argument" line="1064" name="loc" /></scope><scope attributes="protected" ilk="function" line="1074" lineend="1089" name="_parseCache" returns="_parseNoCache()" signature="_parseCache(instring, loc, doActions=True, callPreParse=True)"><variable citdl="ParserElement" ilk="argument" line="1074" name="self" /><variable ilk="argument" line="1074" name="instring" /><variable ilk="argument" line="1074" name="loc" /><variable citdl="True" ilk="argument" line="1074" name="doActions" /><variable citdl="True" ilk="argument" line="1074" name="callPreParse" /><variable citdl="tuple" line="1075" name="lookup" /><variable citdl="_parseNoCache()" line="1077" name="value" /></scope><variable attributes="protected" citdl="ParserElement._parseNoCache" line="1091" name="_parse" /><variable attributes="protected" citdl="dict" line="1094" name="_exprArgCache" /><scope attributes="__staticmethod__" ilk="function" line="1095" lineend="1095" name="resetCache" signature="resetCache() - staticmethod" /><variable attributes="protected" citdl="False" line="1099" name="_packratEnabled" /><scope attributes="__staticmethod__" doc="Enables &quot;packrat&quot; parsing, which adds memoizing to the parsing logic.&#10;Repeated parse attempts at the same string location (which happens&#10;often in many complex grammars) can immediately return a cached value,&#10;instead of re-executing parsing/validating code.  Memoizing is done of&#10;both valid results and parsing exceptions.&#10;&#10;This speedup may break existing programs that use parse actions that&#10;have side-effects.  For this reason, packrat parsing is disabled when&#10;you first import pyparsing.  To activate the packrat feature, your&#10;program must call the class method C{ParserElement.enablePackrat()}.  If&#10;your program uses C{psyco} to &quot;compile as you go&quot;, you must call&#10;C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,&#10;Python will crash.  For best results, call C{enablePackrat()} immediately&#10;after importing pyparsing." ilk="function" line="1100" lineend="1100" name="enablePackrat" signature="enablePackrat() - staticmethod" /><scope doc="Execute the parse expression with the given string.&#10;This is the main interface to the client code, once the complete&#10;expression has been built.&#10;&#10;If you want the grammar to require that the entire input string be&#10;successfully parsed, then set C{parseAll} to True (equivalent to ending&#10;the grammar with C{L{StringEnd()}}).&#10;&#10;Note: C{parseString} implicitly calls C{expandtabs()} on the input string,&#10;in order to report proper column numbers in parse actions.&#10;If the input string contains tabs and&#10;the grammar uses parse actions that use the C{loc} argument to index into the&#10;string being parsed, you can ensure you have a consistent view of the input&#10;string by:&#10; - calling C{parseWithTabs} on your grammar before calling C{parseString}&#10;   (see L{I{parseWithTabs}&lt;parseWithTabs&gt;})&#10; - define your parse action using the full C{(s,loc,toks)} signature, and&#10;   reference the input string using the parse action's C{s} argument&#10; - explictly expand the tabs in your input string before calling&#10;   C{parseString}" ilk="function" line="1121" lineend="1164" name="parseString" signature="parseString(instring, parseAll=False)"><variable citdl="ParserElement" ilk="argument" line="1121" name="self" /><variable citdl="instring.expandtabs()" ilk="argument" line="1121" name="instring" /><variable citdl="False" ilk="argument" line="1121" name="parseAll" /><variable line="1147" name="e" /><variable line="1152" name="tokens" /><variable citdl="preParse()" line="1152" name="loc" /><variable line="1155" name="se" /></scope><scope doc="Scan the input string for expression matches.  Each match will return the&#10;matching tokens, start location, and end location.  May be called with optional&#10;C{maxMatches} argument, to clip scanning after 'n' matches are found.  If&#10;C{overlap} is specified, then overlapping matches will be reported.&#10;&#10;Note that the start and end locations are reported relative to the string&#10;being parsed.  See L{I{parseString}&lt;parseString&gt;} for more information on parsing&#10;strings with embedded tabs." ilk="function" line="1166" lineend="1214" name="scanString" signature="scanString(instring, maxMatches=_MAX_INT, overlap=False)"><variable citdl="ParserElement" ilk="argument" line="1166" name="self" /><variable ilk="argument" line="1166" name="instring" /><variable citdl="sys.maxsize" ilk="argument" line="1166" name="maxMatches" /><variable citdl="False" ilk="argument" line="1166" name="overlap" /><variable line="1177" name="e" /><variable citdl="len()" line="1182" name="instrlen" /><variable citdl="int" line="1183" name="loc" /><variable citdl="ParserElement.preParse" line="1184" name="preparseFn" /><variable citdl="ParserElement._parseNoCache" line="1185" name="parseFn" /><variable citdl="int" line="1187" name="matches" /><variable citdl="preparseFn()" line="1191" name="preloc" /><variable line="1192" name="tokens" /><variable line="1192" name="nextLoc" /><variable citdl="preparseFn()" line="1200" name="nextloc" /></scope><scope doc="Extension to C{L{scanString}}, to modify matching text with modified tokens that may&#10;be returned from a parse action.  To use C{transformString}, define a grammar and&#10;attach a parse action to it that modifies the returned token list.&#10;Invoking C{transformString()} on a target string will then scan for matches,&#10;and replace the matched text patterns according to the logic in the parse&#10;action.  C{transformString()} returns the resulting transformed string." ilk="function" line="1216" lineend="1247" name="transformString" returns="__builtins__.str.join()" signature="transformString(instring)"><variable citdl="ParserElement" ilk="argument" line="1216" name="self" /><variable ilk="argument" line="1216" name="instring" /><variable citdl="list" line="1223" name="out" /><variable citdl="int" line="1224" name="lastE" /><variable line="1229" name="t" /><variable line="1229" name="e" /><variable line="1229" name="s" /></scope><scope doc="Another extension to C{L{scanString}}, simplifying the access to the tokens found&#10;to match the given parse expression.  May be called with optional&#10;C{maxMatches} argument, to clip searching after 'n' matches are found." ilk="function" line="1249" lineend="1261" name="searchString" returns="ParseResults" signature="searchString(instring, maxMatches=_MAX_INT)"><variable citdl="ParserElement" ilk="argument" line="1249" name="self" /><variable ilk="argument" line="1249" name="instring" /><variable citdl="sys.maxsize" ilk="argument" line="1249" name="maxMatches" /></scope><scope doc="Implementation of + operator - returns C{L{And}}" ilk="function" line="1263" lineend="1271" name="__add__" returns="And()" signature="__add__(other)"><variable citdl="ParserElement" ilk="argument" line="1263" name="self" /><variable citdl="literalStringClass()" ilk="argument" line="1263" name="other" /></scope><scope doc="Implementation of + operator when left operand is not a C{L{ParserElement}}" ilk="function" line="1273" lineend="1281" name="__radd__" signature="__radd__(other)"><variable citdl="ParserElement" ilk="argument" line="1273" name="self" /><variable citdl="literalStringClass()" ilk="argument" line="1273" name="other" /></scope><scope doc="Implementation of - operator, returns C{L{And}} with error stop" ilk="function" line="1283" lineend="1291" name="__sub__" returns="And()" signature="__sub__(other)"><variable citdl="ParserElement" ilk="argument" line="1283" name="self" /><variable citdl="literalStringClass()" ilk="argument" line="1283" name="other" /></scope><scope doc="Implementation of - operator when left operand is not a C{L{ParserElement}}" ilk="function" line="1293" lineend="1301" name="__rsub__" signature="__rsub__(other)"><variable citdl="ParserElement" ilk="argument" line="1293" name="self" /><variable citdl="literalStringClass()" ilk="argument" line="1293" name="other" /></scope><scope doc="Implementation of * operator, allows use of C{expr * 3} in place of&#10;C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer&#10;tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples&#10;may also include C{None} as in:&#10; - C{expr*(n,None)} or C{expr*(n,)} is equivalent&#10;   to C{expr*n + L{ZeroOrMore}(expr)}&#10;   (read as &quot;at least n instances of C{expr}&quot;)&#10; - C{expr*(None,n)} is equivalent to C{expr*(0,n)}&#10;   (read as &quot;0 to n instances of C{expr}&quot;)&#10; - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}&#10; - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}&#10;&#10;Note that C{expr*(None,n)} does not raise an exception if&#10;more than n exprs exist in the input stream; that is,&#10;C{expr*(None,n)} does not enforce a maximum number of expr&#10;occurrences.  If this behavior is desired, then write&#10;C{expr*(None,n) + ~expr}" ilk="function" line="1303" lineend="1369" name="__mul__" returns="ParserElement" signature="__mul__(other)"><variable citdl="ParserElement" ilk="argument" line="1303" name="self" /><variable citdl="tuple" ilk="argument" line="1303" name="other" /><variable line="1324" name="minElements" /><variable citdl="int" line="1324" name="optElements" /><scope ilk="function" line="1352" lineend="1356" name="makeOptionalList" returns="Optional()" signature="makeOptionalList(n)"><variable ilk="argument" line="1352" name="n" /></scope><variable citdl="And()" line="1359" name="ret" /></scope><scope ilk="function" line="1371" lineend="1372" name="__rmul__" returns="ParserElement.__mul__()" signature="__rmul__(other)"><variable citdl="ParserElement" ilk="argument" line="1371" name="self" /><variable ilk="argument" line="1371" name="other" /></scope><scope doc="Implementation of | operator - returns C{L{MatchFirst}}" ilk="function" line="1374" lineend="1382" name="__or__" returns="MatchFirst()" signature="__or__(other)"><variable citdl="ParserElement" ilk="argument" line="1374" name="self" /><variable citdl="literalStringClass()" ilk="argument" line="1374" name="other" /></scope><scope doc="Implementation of | operator when left operand is not a C{L{ParserElement}}" ilk="function" line="1384" lineend="1392" name="__ror__" returns="int" signature="__ror__(other)"><variable citdl="ParserElement" ilk="argument" line="1384" name="self" /><variable citdl="literalStringClass()" ilk="argument" line="1384" name="other" /></scope><scope doc="Implementation of ^ operator - returns C{L{Or}}" ilk="function" line="1394" lineend="1402" name="__xor__" returns="Or()" signature="__xor__(other)"><variable citdl="ParserElement" ilk="argument" line="1394" name="self" /><variable citdl="literalStringClass()" ilk="argument" line="1394" name="other" /></scope><scope doc="Implementation of ^ operator when left operand is not a C{L{ParserElement}}" ilk="function" line="1404" lineend="1412" name="__rxor__" returns="int" signature="__rxor__(other)"><variable citdl="ParserElement" ilk="argument" line="1404" name="self" /><variable citdl="literalStringClass()" ilk="argument" line="1404" name="other" /></scope><scope doc="Implementation of &amp; operator - returns C{L{Each}}" ilk="function" line="1414" lineend="1422" name="__and__" returns="Each()" signature="__and__(other)"><variable citdl="ParserElement" ilk="argument" line="1414" name="self" /><variable citdl="literalStringClass()" ilk="argument" line="1414" name="other" /></scope><scope doc="Implementation of &amp; operator when left operand is not a C{L{ParserElement}}" ilk="function" line="1424" lineend="1432" name="__rand__" returns="int" signature="__rand__(other)"><variable citdl="ParserElement" ilk="argument" line="1424" name="self" /><variable citdl="literalStringClass()" ilk="argument" line="1424" name="other" /></scope><scope doc="Implementation of ~ operator - returns C{L{NotAny}}" ilk="function" line="1434" lineend="1436" name="__invert__" returns="NotAny()" signature="__invert__()"><variable citdl="ParserElement" ilk="argument" line="1434" name="self" /></scope><scope doc="Shortcut for C{L{setResultsName}}, with C{listAllMatches=default}::&#10;  userdata = Word(alphas).setResultsName(&quot;name&quot;) + Word(nums+&quot;-&quot;).setResultsName(&quot;socsecno&quot;)&#10;could be written as::&#10;  userdata = Word(alphas)(&quot;name&quot;) + Word(nums+&quot;-&quot;)(&quot;socsecno&quot;)&#10;  &#10;If C{name} is given with a trailing C{'*'} character, then C{listAllMatches} will be&#10;passed as C{True}.&#10;&#10;If C{name} is omitted, same as calling C{L{copy}}." ilk="function" line="1438" lineend="1452" name="__call__" returns="ParserElement.setResultsName()" signature="__call__(name=None)"><variable citdl="ParserElement" ilk="argument" line="1438" name="self" /><variable ilk="argument" line="1438" name="name" /></scope><scope doc="Suppresses the output of this C{ParserElement}; useful to keep punctuation from&#10;cluttering up returned output." ilk="function" line="1454" lineend="1458" name="suppress" returns="Suppress()" signature="suppress()"><variable citdl="ParserElement" ilk="argument" line="1454" name="self" /></scope><scope doc="Disables the skipping of whitespace before matching the characters in the&#10;C{ParserElement}'s defined pattern.  This is normally only used internally by&#10;the pyparsing module, but may be needed in some whitespace-sensitive grammars." ilk="function" line="1460" lineend="1466" name="leaveWhitespace" returns="ParserElement" signature="leaveWhitespace()"><variable citdl="ParserElement" ilk="argument" line="1460" name="self" /></scope><scope doc="Overrides the default whitespace chars&#10;        " ilk="function" line="1468" lineend="1474" name="setWhitespaceChars" returns="ParserElement" signature="setWhitespaceChars(chars)"><variable citdl="ParserElement" ilk="argument" line="1468" name="self" /><variable ilk="argument" line="1468" name="chars" /></scope><scope doc="Overrides default behavior to expand C{&lt;TAB&gt;}s to spaces before parsing the input string.&#10;Must be called before C{parseString} when the input grammar contains elements that&#10;match C{&lt;TAB&gt;} characters." ilk="function" line="1476" lineend="1481" name="parseWithTabs" returns="ParserElement" signature="parseWithTabs()"><variable citdl="ParserElement" ilk="argument" line="1476" name="self" /></scope><scope doc="Define expression to be ignored (e.g., comments) while doing pattern&#10;matching; may be called repeatedly, to define multiple comment or other&#10;ignorable patterns." ilk="function" line="1483" lineend="1496" name="ignore" returns="ParserElement" signature="ignore(other)"><variable citdl="ParserElement" ilk="argument" line="1483" name="self" /><variable citdl="Suppress()" ilk="argument" line="1483" name="other" /></scope><scope doc="Enable display of debugging messages while doing pattern matching." ilk="function" line="1498" lineend="1504" name="setDebugActions" returns="ParserElement" signature="setDebugActions(startAction, successAction, exceptionAction)"><variable citdl="ParserElement" ilk="argument" line="1498" name="self" /><variable ilk="argument" line="1498" name="startAction" /><variable ilk="argument" line="1498" name="successAction" /><variable ilk="argument" line="1498" name="exceptionAction" /></scope><scope doc="Enable display of debugging messages while doing pattern matching.&#10;Set C{flag} to True to enable, False to disable." ilk="function" line="1506" lineend="1513" name="setDebug" returns="ParserElement" signature="setDebug(flag=True)"><variable citdl="ParserElement" ilk="argument" line="1506" name="self" /><variable citdl="True" ilk="argument" line="1506" name="flag" /></scope><scope ilk="function" line="1515" lineend="1516" name="__str__" signature="__str__()"><variable citdl="ParserElement" ilk="argument" line="1515" name="self" /></scope><scope ilk="function" line="1518" lineend="1519" name="__repr__" returns="_ustr()" signature="__repr__()"><variable citdl="ParserElement" ilk="argument" line="1518" name="self" /></scope><scope ilk="function" line="1521" lineend="1524" name="streamline" returns="ParserElement" signature="streamline()"><variable citdl="ParserElement" ilk="argument" line="1521" name="self" /></scope><scope ilk="function" line="1526" lineend="1527" name="checkRecursion" signature="checkRecursion(parseElementList)"><variable citdl="ParserElement" ilk="argument" line="1526" name="self" /><variable ilk="argument" line="1526" name="parseElementList" /></scope><scope doc="Check defined expressions for valid structure, check for infinite recursive definitions." ilk="function" line="1529" lineend="1531" name="validate" signature="validate(validateTrace=[])"><variable citdl="ParserElement" ilk="argument" line="1529" name="self" /><variable citdl="list" ilk="argument" line="1529" name="validateTrace" /></scope><scope doc="Execute the parse expression on the given file or filename.&#10;If a filename is specified (instead of a file object),&#10;the entire file is opened, read, and closed before parsing." ilk="function" line="1533" lineend="1551" name="parseFile" returns="ParserElement.parseString()" signature="parseFile(file_or_filename, parseAll=False)"><variable citdl="ParserElement" ilk="argument" line="1533" name="self" /><variable ilk="argument" line="1533" name="file_or_filename" /><variable citdl="False" ilk="argument" line="1533" name="parseAll" /><variable citdl="f.read()" line="1539" name="file_contents" /><variable citdl="open()" line="1541" name="f" /></scope><scope ilk="function" line="1553" lineend="1563" name="__eq__" returns="bool" signature="__eq__(other)"><variable citdl="ParserElement" ilk="argument" line="1553" name="self" /><variable ilk="argument" line="1553" name="other" /></scope><scope ilk="function" line="1565" lineend="1566" name="__ne__" returns="bool" signature="__ne__(other)"><variable citdl="ParserElement" ilk="argument" line="1565" name="self" /><variable ilk="argument" line="1565" name="other" /></scope><scope ilk="function" line="1568" lineend="1569" name="__hash__" returns="hash()" signature="__hash__()"><variable citdl="ParserElement" ilk="argument" line="1568" name="self" /></scope><scope ilk="function" line="1571" lineend="1572" name="__req__" returns="bool" signature="__req__(other)"><variable citdl="ParserElement" ilk="argument" line="1571" name="self" /><variable ilk="argument" line="1571" name="other" /></scope><scope ilk="function" line="1574" lineend="1575" name="__rne__" returns="bool" signature="__rne__(other)"><variable citdl="ParserElement" ilk="argument" line="1574" name="self" /><variable ilk="argument" line="1574" name="other" /></scope><scope doc="Execute the parse expression on a series of test strings, showing each&#10;test, the parsed results or where the parse failed. Quick and easy way to&#10;run a parse expression against a list of sample strings.&#10;&#10;Parameters:&#10; - tests - a list of separate test strings, or a multiline string of test strings&#10; - parseAll - (default=False) - flag to pass to C{L{parseString}} when running tests           " ilk="function" line="1577" lineend="1600" name="runTests" signature="runTests(tests, parseAll=False)"><variable citdl="ParserElement" ilk="argument" line="1577" name="self" /><variable citdl="map()" ilk="argument" line="1577" name="tests" /><variable citdl="False" ilk="argument" line="1577" name="parseAll" /><variable line="1588" name="t" /><variable citdl="list" line="1589" name="out" /></scope></scope><scope classrefs="ParserElement" doc="Abstract C{ParserElement} subclass, for defining atomic matching patterns." ilk="class" line="1603" lineend="1606" name="Token"><scope attributes="__ctor__" ilk="function" line="1605" lineend="1606" name="__init__" signature="Token()"><variable citdl="Token" ilk="argument" line="1605" name="self" /></scope></scope><scope classrefs="Token" doc="An empty token, will always match." ilk="class" line="1609" lineend="1615" name="Empty"><scope attributes="__ctor__" ilk="function" line="1611" lineend="1615" name="__init__" signature="Empty()"><variable citdl="Empty" ilk="argument" line="1611" name="self" /></scope><variable attributes="__instancevar__" citdl="str" line="1613" name="name" /><variable attributes="__instancevar__" citdl="True" line="1614" name="mayReturnEmpty" /><variable attributes="__instancevar__" citdl="False" line="1615" name="mayIndexError" /></scope><scope classrefs="Token" doc="A token that will never match." ilk="class" line="1618" lineend="1628" name="NoMatch"><scope attributes="__ctor__" ilk="function" line="1620" lineend="1625" name="__init__" signature="NoMatch()"><variable citdl="NoMatch" ilk="argument" line="1620" name="self" /></scope><variable attributes="__instancevar__" citdl="str" line="1622" name="name" /><variable attributes="__instancevar__" citdl="True" line="1623" name="mayReturnEmpty" /><variable attributes="__instancevar__" citdl="False" line="1624" name="mayIndexError" /><variable attributes="__instancevar__" citdl="str" line="1625" name="errmsg" /><scope ilk="function" line="1627" lineend="1628" name="parseImpl" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="NoMatch" ilk="argument" line="1627" name="self" /><variable ilk="argument" line="1627" name="instring" /><variable ilk="argument" line="1627" name="loc" /><variable citdl="True" ilk="argument" line="1627" name="doActions" /></scope></scope><scope classrefs="Token" doc="Token to exactly match a specified string." ilk="class" line="1631" lineend="1656" name="Literal"><scope attributes="__ctor__" ilk="function" line="1633" lineend="1646" name="__init__" signature="Literal(matchString)"><variable citdl="Literal" ilk="argument" line="1633" name="self" /><variable ilk="argument" line="1633" name="matchString" /></scope><variable attributes="__instancevar__" line="1635" name="match" /><variable attributes="__instancevar__" citdl="len()" line="1636" name="matchLen" /><variable attributes="__instancevar__" line="1638" name="firstMatchChar" /><variable attributes="__instancevar__" citdl="Empty" line="1642" name="__class__" /><variable attributes="__instancevar__" line="1643" name="name" /><variable attributes="__instancevar__" line="1644" name="errmsg" /><variable attributes="__instancevar__" citdl="False" line="1645" name="mayReturnEmpty" /><variable attributes="__instancevar__" citdl="False" line="1646" name="mayIndexError" /><scope ilk="function" line="1652" lineend="1656" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="Literal" ilk="argument" line="1652" name="self" /><variable ilk="argument" line="1652" name="instring" /><variable ilk="argument" line="1652" name="loc" /><variable citdl="True" ilk="argument" line="1652" name="doActions" /></scope></scope><variable attributes="protected" citdl="Literal" line="1657" name="_L" /><scope classrefs="Token" doc="Token to exactly match a specified string as a keyword, that is, it must be&#10;immediately followed by a non-keyword character.  Compare with C{L{Literal}}::&#10;  Literal(&quot;if&quot;) will match the leading C{'if'} in C{'ifAndOnlyIf'}.&#10;  Keyword(&quot;if&quot;) will not; it will only match the leading C{'if'} in C{'if x=1'}, or C{'if(y==2)'}&#10;Accepts two optional constructor arguments in addition to the keyword string:&#10;C{identChars} is a string of characters that would be valid identifier characters,&#10;defaulting to all alphanumerics + &quot;_&quot; and &quot;$&quot;; C{caseless} allows case-insensitive&#10;matching, default is C{False}." ilk="class" line="1660" lineend="1710" name="Keyword"><variable citdl="Keyword" line="1670" name="DEFAULT_KEYWORD_CHARS" /><scope attributes="__ctor__" ilk="function" line="1672" lineend="1689" name="__init__" signature="Keyword(matchString, identChars=DEFAULT_KEYWORD_CHARS, caseless=False)"><variable citdl="Keyword" ilk="argument" line="1672" name="self" /><variable ilk="argument" line="1672" name="matchString" /><variable citdl="identChars.upper()" ilk="argument" line="1672" name="identChars" /><variable citdl="False" ilk="argument" line="1672" name="caseless" /></scope><variable attributes="__instancevar__" line="1674" name="match" /><variable attributes="__instancevar__" citdl="len()" line="1675" name="matchLen" /><variable attributes="__instancevar__" line="1677" name="firstMatchChar" /><variable attributes="__instancevar__" line="1681" name="name" /><variable attributes="__instancevar__" line="1682" name="errmsg" /><variable attributes="__instancevar__" citdl="False" line="1683" name="mayReturnEmpty" /><variable attributes="__instancevar__" citdl="False" line="1684" name="mayIndexError" /><variable attributes="__instancevar__" citdl="False" line="1685" name="caseless" /><variable attributes="__instancevar__" citdl="matchString.upper()" line="1687" name="caselessmatch" /><variable attributes="__instancevar__" citdl="set()" line="1689" name="identChars" /><scope ilk="function" line="1691" lineend="1703" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="Keyword" ilk="argument" line="1691" name="self" /><variable ilk="argument" line="1691" name="instring" /><variable ilk="argument" line="1691" name="loc" /><variable citdl="True" ilk="argument" line="1691" name="doActions" /></scope><scope ilk="function" line="1705" lineend="1708" name="copy" signature="copy()"><variable citdl="Keyword" ilk="argument" line="1705" name="self" /><variable line="1706" name="c" /></scope><scope attributes="__staticmethod__" doc="Overrides the default Keyword chars&#10;        " ilk="function" line="1710" lineend="1710" name="setDefaultKeywordChars" signature="setDefaultKeywordChars(chars) - staticmethod"><variable citdl="Keyword" ilk="argument" line="1710" name="chars" /></scope></scope><scope classrefs="Literal" doc="Token to match a specified string, ignoring case of letters.&#10;Note: the matched results will always be in the case of the given&#10;match string, NOT the case of the input text." ilk="class" line="1716" lineend="1731" name="CaselessLiteral"><scope attributes="__ctor__" ilk="function" line="1721" lineend="1726" name="__init__" signature="CaselessLiteral(matchString)"><variable citdl="CaselessLiteral" ilk="argument" line="1721" name="self" /><variable ilk="argument" line="1721" name="matchString" /></scope><variable attributes="__instancevar__" line="1724" name="returnString" /><variable attributes="__instancevar__" line="1725" name="name" /><variable attributes="__instancevar__" line="1726" name="errmsg" /><scope ilk="function" line="1728" lineend="1731" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="CaselessLiteral" ilk="argument" line="1728" name="self" /><variable ilk="argument" line="1728" name="instring" /><variable ilk="argument" line="1728" name="loc" /><variable citdl="True" ilk="argument" line="1728" name="doActions" /></scope></scope><scope classrefs="Keyword" ilk="class" line="1733" lineend="1741" name="CaselessKeyword"><scope attributes="__ctor__" ilk="function" line="1734" lineend="1735" name="__init__" signature="CaselessKeyword(matchString, identChars=Keyword.DEFAULT_KEYWORD_CHARS)"><variable citdl="CaselessKeyword" ilk="argument" line="1734" name="self" /><variable ilk="argument" line="1734" name="matchString" /><variable citdl="Keyword" ilk="argument" line="1734" name="identChars" /></scope><scope ilk="function" line="1737" lineend="1741" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="CaselessKeyword" ilk="argument" line="1737" name="self" /><variable ilk="argument" line="1737" name="instring" /><variable ilk="argument" line="1737" name="loc" /><variable citdl="True" ilk="argument" line="1737" name="doActions" /></scope></scope><scope classrefs="Token" doc="Token for matching words composed of allowed character sets.&#10;Defined with string containing all allowed initial characters,&#10;an optional string containing allowed body characters (if omitted,&#10;defaults to the initial character set), and an optional minimum,&#10;maximum, and/or exact length.  The default value for C{min} is 1 (a&#10;minimum value &lt; 1 is not valid); the default values for C{max} and C{exact}&#10;are 0, meaning no maximum or exact length restriction. An optional&#10;C{excludeChars} parameter can list characters that might be found in &#10;the input C{bodyChars} string; useful to define a word of all printables&#10;except for one or two characters, for instance." ilk="class" line="1743" lineend="1864" name="Word"><scope attributes="__ctor__" ilk="function" line="1755" lineend="1807" name="__init__" signature="Word(initChars, bodyChars=None, min=1, max=0, exact=0, asKeyword=False, excludeChars=None)"><variable citdl="Word" ilk="argument" line="1755" name="self" /><variable citdl="__builtins__.str.join()" ilk="argument" line="1755" name="initChars" /><variable citdl="__builtins__.str.join()" ilk="argument" line="1755" name="bodyChars" /><variable citdl="int" ilk="argument" line="1755" name="min" /><variable citdl="int" ilk="argument" line="1755" name="max" /><variable citdl="int" ilk="argument" line="1755" name="exact" /><variable citdl="False" ilk="argument" line="1755" name="asKeyword" /><variable ilk="argument" line="1755" name="excludeChars" /></scope><variable attributes="__instancevar__" citdl="__builtins__.str.join()" line="1761" name="initCharsOrig" /><variable attributes="__instancevar__" citdl="set()" line="1762" name="initChars" /><variable attributes="__instancevar__" citdl="__builtins__.str.join()" line="1764" name="bodyCharsOrig" /><variable attributes="__instancevar__" citdl="set()" line="1765" name="bodyChars" /><variable attributes="__instancevar__" citdl="bool" line="1770" name="maxSpecified" /><variable attributes="__instancevar__" citdl="int" line="1775" name="minLen" /><variable attributes="__instancevar__" citdl="int" line="1778" name="maxLen" /><variable attributes="__instancevar__" citdl="_ustr()" line="1786" name="name" /><variable attributes="__instancevar__" line="1787" name="errmsg" /><variable attributes="__instancevar__" citdl="False" line="1788" name="mayIndexError" /><variable attributes="__instancevar__" citdl="False" line="1789" name="asKeyword" /><variable attributes="__instancevar__" line="1793" name="reString" /><variable attributes="__instancevar__" citdl="re.compile()" line="1805" name="re" /><scope ilk="function" line="1809" lineend="1842" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="Word" ilk="argument" line="1809" name="self" /><variable ilk="argument" line="1809" name="instring" /><variable citdl="result.end()" ilk="argument" line="1809" name="loc" /><variable citdl="True" ilk="argument" line="1809" name="doActions" /><variable citdl="self.re.match()" line="1811" name="result" /><variable citdl="result.end()" line="1821" name="start" /><variable citdl="len()" line="1823" name="instrlen" /><variable citdl="set()" line="1824" name="bodychars" /><variable citdl="min()" line="1825" name="maxloc" /><variable citdl="True" line="1830" name="throwException" /></scope><scope ilk="function" line="1844" lineend="1864" name="__str__" signature="__str__()"><variable citdl="Word" ilk="argument" line="1844" name="self" /><scope ilk="function" line="1853" lineend="1857" name="charsAsStr" signature="charsAsStr(s)"><variable ilk="argument" line="1853" name="s" /></scope></scope><variable attributes="__instancevar__" line="1860" name="strRepr" /></scope><scope classrefs="Token" doc="Token for matching strings that match a given regular expression.&#10;Defined with string specifying the regular expression in a form recognized by the inbuilt Python re module." ilk="class" line="1867" lineend="1928" name="Regex"><variable citdl="type()" line="1871" name="compiledREtype" /><scope attributes="__ctor__" doc="The parameters C{pattern} and C{flags} are passed to the C{re.compile()} function as-is. See the Python C{re} module for an explanation of the acceptable patterns and flags." ilk="function" line="1872" lineend="1904" name="__init__" signature="Regex(pattern, flags=0)"><variable citdl="Regex" ilk="argument" line="1872" name="self" /><variable ilk="argument" line="1872" name="pattern" /><variable citdl="int" ilk="argument" line="1872" name="flags" /></scope><variable attributes="__instancevar__" citdl="str()" line="1881" name="pattern" /><variable attributes="__instancevar__" citdl="int" line="1882" name="flags" /><variable attributes="__instancevar__" citdl="re.compile()" line="1885" name="re" /><variable attributes="__instancevar__" line="1886" name="reString" /><variable attributes="__instancevar__" citdl="_ustr()" line="1901" name="name" /><variable attributes="__instancevar__" line="1902" name="errmsg" /><variable attributes="__instancevar__" citdl="False" line="1903" name="mayIndexError" /><variable attributes="__instancevar__" citdl="True" line="1904" name="mayReturnEmpty" /><scope ilk="function" line="1906" lineend="1917" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="Regex" ilk="argument" line="1906" name="self" /><variable ilk="argument" line="1906" name="instring" /><variable citdl="result.end()" ilk="argument" line="1906" name="loc" /><variable citdl="True" ilk="argument" line="1906" name="doActions" /><variable citdl="self.re.match()" line="1907" name="result" /><variable citdl="result.groupdict()" line="1912" name="d" /><variable citdl="ParseResults" line="1913" name="ret" /><variable line="1915" name="k" /></scope><scope ilk="function" line="1919" lineend="1928" name="__str__" signature="__str__()"><variable citdl="Regex" ilk="argument" line="1919" name="self" /></scope><variable attributes="__instancevar__" line="1926" name="strRepr" /></scope><scope classrefs="Token" doc="Token for matching strings that are delimited by quoting characters.&#10;    " ilk="class" line="1931" lineend="2040" name="QuotedString"><scope attributes="__ctor__" doc="Defined with the following parameters:&#10;- quoteChar - string of one or more characters defining the quote delimiting string&#10;- escChar - character to escape quotes, typically backslash (default=None)&#10;- escQuote - special quote sequence to escape an embedded quote string (such as SQL's &quot;&quot; to escape an embedded &quot;) (default=None)&#10;- multiline - boolean indicating whether quotes can span multiple lines (default=C{False})&#10;- unquoteResults - boolean indicating whether the matched text should be unquoted (default=C{True})&#10;- endQuoteChar - string of one or more characters defining the end of the quote delimited string (default=C{None} =&gt; same as quoteChar)" ilk="function" line="1934" lineend="2005" name="__init__" signature="QuotedString(quoteChar, escChar=None, escQuote=None, multiline=False, unquoteResults=True, endQuoteChar=None)"><variable citdl="QuotedString" ilk="argument" line="1934" name="self" /><variable citdl="quoteChar.strip()" ilk="argument" line="1934" name="quoteChar" /><variable ilk="argument" line="1934" name="escChar" /><variable ilk="argument" line="1934" name="escQuote" /><variable citdl="False" ilk="argument" line="1934" name="multiline" /><variable citdl="True" ilk="argument" line="1934" name="unquoteResults" /><variable citdl="quoteChar.strip()" ilk="argument" line="1934" name="endQuoteChar" /></scope><variable attributes="__instancevar__" citdl="quoteChar.strip()" line="1960" name="quoteChar" /><variable attributes="__instancevar__" citdl="len()" line="1961" name="quoteCharLen" /><variable attributes="__instancevar__" line="1962" name="firstQuoteChar" /><variable attributes="__instancevar__" citdl="quoteChar.strip()" line="1963" name="endQuoteChar" /><variable attributes="__instancevar__" citdl="len()" line="1964" name="endQuoteCharLen" /><variable attributes="__instancevar__" line="1965" name="escChar" /><variable attributes="__instancevar__" line="1966" name="escQuote" /><variable attributes="__instancevar__" citdl="True" line="1967" name="unquoteResults" /><variable attributes="__instancevar__" citdl="int" line="1970" name="flags" /><variable attributes="__instancevar__" line="1971" name="pattern" /><variable attributes="__instancevar__" line="1991" name="escCharReplacePattern" /><variable attributes="__instancevar__" citdl="re.compile()" line="1995" name="re" /><variable attributes="__instancevar__" line="1996" name="reString" /><variable attributes="__instancevar__" citdl="_ustr()" line="2002" name="name" /><variable attributes="__instancevar__" line="2003" name="errmsg" /><variable attributes="__instancevar__" citdl="False" line="2004" name="mayIndexError" /><variable attributes="__instancevar__" citdl="True" line="2005" name="mayReturnEmpty" /><scope ilk="function" line="2007" lineend="2029" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="QuotedString" ilk="argument" line="2007" name="self" /><variable ilk="argument" line="2007" name="instring" /><variable citdl="result.end()" ilk="argument" line="2007" name="loc" /><variable citdl="True" ilk="argument" line="2007" name="doActions" /><variable citdl="self.re.match()" line="2008" name="result" /><variable citdl="re.sub()" line="2013" name="ret" /></scope><scope ilk="function" line="2031" lineend="2040" name="__str__" signature="__str__()"><variable citdl="QuotedString" ilk="argument" line="2031" name="self" /></scope><variable attributes="__instancevar__" line="2038" name="strRepr" /></scope><scope classrefs="Token" doc="Token for matching words composed of characters *not* in a given set.&#10;Defined with string containing all disallowed characters, and an optional&#10;minimum, maximum, and/or exact length.  The default value for C{min} is 1 (a&#10;minimum value &lt; 1 is not valid); the default values for C{max} and C{exact}&#10;are 0, meaning no maximum or exact length restriction." ilk="class" line="2043" lineend="2103" name="CharsNotIn"><scope attributes="__ctor__" ilk="function" line="2050" lineend="2072" name="__init__" signature="CharsNotIn(notChars, min=1, max=0, exact=0)"><variable citdl="CharsNotIn" ilk="argument" line="2050" name="self" /><variable ilk="argument" line="2050" name="notChars" /><variable citdl="int" ilk="argument" line="2050" name="min" /><variable citdl="int" ilk="argument" line="2050" name="max" /><variable citdl="int" ilk="argument" line="2050" name="exact" /></scope><variable attributes="__instancevar__" citdl="False" line="2052" name="skipWhitespace" /><variable attributes="__instancevar__" line="2053" name="notChars" /><variable attributes="__instancevar__" citdl="int" line="2058" name="minLen" /><variable attributes="__instancevar__" citdl="int" line="2061" name="maxLen" /><variable attributes="__instancevar__" citdl="_ustr()" line="2069" name="name" /><variable attributes="__instancevar__" line="2070" name="errmsg" /><variable attributes="__instancevar__" citdl="bool" line="2071" name="mayReturnEmpty" /><variable attributes="__instancevar__" citdl="False" line="2072" name="mayIndexError" /><scope ilk="function" line="2074" lineend="2089" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="CharsNotIn" ilk="argument" line="2074" name="self" /><variable ilk="argument" line="2074" name="instring" /><variable ilk="argument" line="2074" name="loc" /><variable citdl="True" ilk="argument" line="2074" name="doActions" /><variable line="2078" name="start" /><variable line="2080" name="notchars" /><variable citdl="min()" line="2081" name="maxlen" /></scope><scope ilk="function" line="2091" lineend="2103" name="__str__" signature="__str__()"><variable citdl="CharsNotIn" ilk="argument" line="2091" name="self" /></scope><variable attributes="__instancevar__" line="2099" name="strRepr" /></scope><scope classrefs="Token" doc="Special matching class for matching whitespace.  Normally, whitespace is ignored&#10;by pyparsing grammars.  This class is included when some whitespace structures&#10;are significant.  Define with a string containing the whitespace characters to be&#10;matched; default is C{&quot; \t\r\n&quot;}.  Also takes optional C{min}, C{max}, and C{exact} arguments,&#10;as defined for the C{L{Word}} class." ilk="class" line="2105" lineend="2151" name="White"><variable citdl="dict" line="2111" name="whiteStrs" /><scope attributes="__ctor__" ilk="function" line="2118" lineend="2136" name="__init__" signature="White(ws=' \t\r\n', min=1, max=0, exact=0)"><variable citdl="White" ilk="argument" line="2118" name="self" /><variable citdl="str" ilk="argument" line="2118" name="ws" /><variable citdl="int" ilk="argument" line="2118" name="min" /><variable citdl="int" ilk="argument" line="2118" name="max" /><variable citdl="int" ilk="argument" line="2118" name="exact" /></scope><variable attributes="__instancevar__" citdl="str" line="2120" name="matchWhite" /><variable attributes="__instancevar__" citdl="__builtins__.str.join()" line="2123" name="name" /><variable attributes="__instancevar__" citdl="True" line="2124" name="mayReturnEmpty" /><variable attributes="__instancevar__" line="2125" name="errmsg" /><variable attributes="__instancevar__" citdl="int" line="2127" name="minLen" /><variable attributes="__instancevar__" citdl="int" line="2130" name="maxLen" /><scope ilk="function" line="2138" lineend="2151" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="White" ilk="argument" line="2138" name="self" /><variable ilk="argument" line="2138" name="instring" /><variable ilk="argument" line="2138" name="loc" /><variable citdl="True" ilk="argument" line="2138" name="doActions" /><variable line="2141" name="start" /><variable citdl="min()" line="2143" name="maxloc" /></scope></scope><scope attributes="protected" classrefs="Token" ilk="class" line="2154" lineend="2159" name="_PositionToken"><scope attributes="__ctor__" ilk="function" line="2155" lineend="2159" name="__init__" signature="_PositionToken()"><variable citdl="_PositionToken" ilk="argument" line="2155" name="self" /></scope><variable attributes="__instancevar__" citdl="self.__class__.__name__" line="2157" name="name" /><variable attributes="__instancevar__" citdl="True" line="2158" name="mayReturnEmpty" /><variable attributes="__instancevar__" citdl="False" line="2159" name="mayIndexError" /></scope><scope classrefs="_PositionToken" doc="Token to advance to a specific column of input text; useful for tabular report scraping." ilk="class" line="2161" lineend="2182" name="GoToColumn"><scope attributes="__ctor__" ilk="function" line="2163" lineend="2165" name="__init__" signature="GoToColumn(colno)"><variable citdl="GoToColumn" ilk="argument" line="2163" name="self" /><variable ilk="argument" line="2163" name="colno" /></scope><variable attributes="__instancevar__" line="2165" name="col" /><scope ilk="function" line="2167" lineend="2174" name="preParse" returns="self._skipIgnorables()" signature="preParse(instring, loc)"><variable citdl="GoToColumn" ilk="argument" line="2167" name="self" /><variable ilk="argument" line="2167" name="instring" /><variable citdl="self._skipIgnorables()" ilk="argument" line="2167" name="loc" /><variable citdl="len()" line="2169" name="instrlen" /></scope><scope ilk="function" line="2176" lineend="2182" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="GoToColumn" ilk="argument" line="2176" name="self" /><variable ilk="argument" line="2176" name="instring" /><variable ilk="argument" line="2176" name="loc" /><variable citdl="True" ilk="argument" line="2176" name="doActions" /><variable citdl="col()" line="2177" name="thiscol" /><variable line="2180" name="newloc" /><variable line="2181" name="ret" /></scope></scope><scope classrefs="_PositionToken" doc="Matches if current position is at the beginning of a line within the parse string" ilk="class" line="2184" lineend="2202" name="LineStart"><scope attributes="__ctor__" ilk="function" line="2186" lineend="2189" name="__init__" signature="LineStart()"><variable citdl="LineStart" ilk="argument" line="2186" name="self" /></scope><variable attributes="__instancevar__" citdl="str" line="2189" name="errmsg" /><scope ilk="function" line="2191" lineend="2195" name="preParse" signature="preParse(instring, loc)"><variable citdl="LineStart" ilk="argument" line="2191" name="self" /><variable ilk="argument" line="2191" name="instring" /><variable ilk="argument" line="2191" name="loc" /><variable line="2192" name="preloc" /></scope><scope ilk="function" line="2197" lineend="2202" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="LineStart" ilk="argument" line="2197" name="self" /><variable ilk="argument" line="2197" name="instring" /><variable ilk="argument" line="2197" name="loc" /><variable citdl="True" ilk="argument" line="2197" name="doActions" /></scope></scope><scope classrefs="_PositionToken" doc="Matches if current position is at the end of a line within the parse string" ilk="class" line="2204" lineend="2220" name="LineEnd"><scope attributes="__ctor__" ilk="function" line="2206" lineend="2209" name="__init__" signature="LineEnd()"><variable citdl="LineEnd" ilk="argument" line="2206" name="self" /></scope><variable attributes="__instancevar__" citdl="str" line="2209" name="errmsg" /><scope ilk="function" line="2211" lineend="2220" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="LineEnd" ilk="argument" line="2211" name="self" /><variable ilk="argument" line="2211" name="instring" /><variable ilk="argument" line="2211" name="loc" /><variable citdl="True" ilk="argument" line="2211" name="doActions" /></scope></scope><scope classrefs="_PositionToken" doc="Matches if current position is at the beginning of the parse string" ilk="class" line="2222" lineend="2233" name="StringStart"><scope attributes="__ctor__" ilk="function" line="2224" lineend="2226" name="__init__" signature="StringStart()"><variable citdl="StringStart" ilk="argument" line="2224" name="self" /></scope><variable attributes="__instancevar__" citdl="str" line="2226" name="errmsg" /><scope ilk="function" line="2228" lineend="2233" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="StringStart" ilk="argument" line="2228" name="self" /><variable ilk="argument" line="2228" name="instring" /><variable ilk="argument" line="2228" name="loc" /><variable citdl="True" ilk="argument" line="2228" name="doActions" /></scope></scope><scope classrefs="_PositionToken" doc="Matches if current position is at the end of the parse string" ilk="class" line="2235" lineend="2249" name="StringEnd"><scope attributes="__ctor__" ilk="function" line="2237" lineend="2239" name="__init__" signature="StringEnd()"><variable citdl="StringEnd" ilk="argument" line="2237" name="self" /></scope><variable attributes="__instancevar__" citdl="str" line="2239" name="errmsg" /><scope ilk="function" line="2241" lineend="2249" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="StringEnd" ilk="argument" line="2241" name="self" /><variable ilk="argument" line="2241" name="instring" /><variable ilk="argument" line="2241" name="loc" /><variable citdl="True" ilk="argument" line="2241" name="doActions" /></scope></scope><scope classrefs="_PositionToken" doc="Matches if the current position is at the beginning of a Word, and&#10;is not preceded by any character in a given set of C{wordChars}&#10;(default=C{printables}). To emulate the C{&amp;#8;} behavior of regular expressions,&#10;use C{WordStart(alphanums)}. C{WordStart} will also match at the beginning of&#10;the string being parsed, or at the beginning of a line." ilk="class" line="2251" lineend="2268" name="WordStart"><scope attributes="__ctor__" ilk="function" line="2258" lineend="2261" name="__init__" signature="WordStart(wordChars=printables)"><variable citdl="WordStart" ilk="argument" line="2258" name="self" /><variable citdl="__builtins__.str.join()" ilk="argument" line="2258" name="wordChars" /></scope><variable attributes="__instancevar__" citdl="set()" line="2260" name="wordChars" /><variable attributes="__instancevar__" citdl="str" line="2261" name="errmsg" /><scope ilk="function" line="2263" lineend="2268" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="WordStart" ilk="argument" line="2263" name="self" /><variable ilk="argument" line="2263" name="instring" /><variable ilk="argument" line="2263" name="loc" /><variable citdl="True" ilk="argument" line="2263" name="doActions" /></scope></scope><scope classrefs="_PositionToken" doc="Matches if the current position is at the end of a Word, and&#10;is not followed by any character in a given set of C{wordChars}&#10;(default=C{printables}). To emulate the C{&amp;#8;} behavior of regular expressions,&#10;use C{WordEnd(alphanums)}. C{WordEnd} will also match at the end of&#10;the string being parsed, or at the end of a line." ilk="class" line="2270" lineend="2289" name="WordEnd"><scope attributes="__ctor__" ilk="function" line="2277" lineend="2281" name="__init__" signature="WordEnd(wordChars=printables)"><variable citdl="WordEnd" ilk="argument" line="2277" name="self" /><variable citdl="__builtins__.str.join()" ilk="argument" line="2277" name="wordChars" /></scope><variable attributes="__instancevar__" citdl="set()" line="2279" name="wordChars" /><variable attributes="__instancevar__" citdl="False" line="2280" name="skipWhitespace" /><variable attributes="__instancevar__" citdl="str" line="2281" name="errmsg" /><scope ilk="function" line="2283" lineend="2289" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="WordEnd" ilk="argument" line="2283" name="self" /><variable ilk="argument" line="2283" name="instring" /><variable ilk="argument" line="2283" name="loc" /><variable citdl="True" ilk="argument" line="2283" name="doActions" /><variable citdl="len()" line="2284" name="instrlen" /></scope></scope><scope classrefs="ParserElement" doc="Abstract subclass of ParserElement, for combining and post-processing parsed tokens." ilk="class" line="2292" lineend="2399" name="ParseExpression"><scope attributes="__ctor__" ilk="function" line="2294" lineend="2311" name="__init__" signature="ParseExpression(exprs, savelist=False)"><variable citdl="ParseExpression" ilk="argument" line="2294" name="self" /><variable citdl="list()" ilk="argument" line="2294" name="exprs" /><variable citdl="False" ilk="argument" line="2294" name="savelist" /></scope><variable attributes="__instancevar__" citdl="list" line="2300" name="exprs" /><variable attributes="__instancevar__" citdl="False" line="2311" name="callPreparse" /><scope ilk="function" line="2313" lineend="2314" name="__getitem__" signature="__getitem__(i)"><variable citdl="ParseExpression" ilk="argument" line="2313" name="self" /><variable ilk="argument" line="2313" name="i" /></scope><scope ilk="function" line="2316" lineend="2319" name="append" returns="ParseExpression" signature="append(other)"><variable citdl="ParseExpression" ilk="argument" line="2316" name="self" /><variable ilk="argument" line="2316" name="other" /></scope><variable attributes="__instancevar__" line="2318" name="strRepr" /><scope doc="Extends C{leaveWhitespace} defined in base class, and also invokes C{leaveWhitespace} on&#10;all contained expressions." ilk="function" line="2321" lineend="2328" name="leaveWhitespace" returns="ParseExpression" signature="leaveWhitespace()"><variable citdl="ParseExpression" ilk="argument" line="2321" name="self" /><variable line="2326" name="e" /></scope><variable attributes="__instancevar__" citdl="False" line="2324" name="skipWhitespace" /><scope ilk="function" line="2330" lineend="2340" name="ignore" returns="ParseExpression" signature="ignore(other)"><variable citdl="ParseExpression" ilk="argument" line="2330" name="self" /><variable ilk="argument" line="2330" name="other" /><variable line="2334" name="e" /></scope><scope ilk="function" line="2342" lineend="2350" name="__str__" signature="__str__()"><variable citdl="ParseExpression" ilk="argument" line="2342" name="self" /></scope><scope ilk="function" line="2352" lineend="2384" name="streamline" returns="ParseExpression" signature="streamline()"><variable citdl="ParseExpression" ilk="argument" line="2352" name="self" /><variable line="2355" name="e" /><variable line="2362" name="other" /></scope><variable attributes="__instancevar__" line="2382" name="errmsg" /><scope ilk="function" line="2386" lineend="2388" name="setResultsName" signature="setResultsName(name, listAllMatches=False)"><variable citdl="ParseExpression" ilk="argument" line="2386" name="self" /><variable ilk="argument" line="2386" name="name" /><variable citdl="False" ilk="argument" line="2386" name="listAllMatches" /><variable line="2387" name="ret" /></scope><scope ilk="function" line="2390" lineend="2394" name="validate" signature="validate(validateTrace=[])"><variable citdl="ParseExpression" ilk="argument" line="2390" name="self" /><variable citdl="list" ilk="argument" line="2390" name="validateTrace" /><variable line="2391" name="tmp" /><variable line="2392" name="e" /></scope><scope ilk="function" line="2396" lineend="2399" name="copy" signature="copy()"><variable citdl="ParseExpression" ilk="argument" line="2396" name="self" /><variable line="2397" name="ret" /></scope></scope><scope classrefs="ParseExpression" doc="Requires all given C{ParseExpression}s to be found in the given order.&#10;Expressions may be separated by whitespace.&#10;May be constructed using the C{'+'} operator." ilk="class" line="2401" lineend="2464" name="And"><scope attributes="protected" classrefs="Empty" ilk="class" line="2407" lineend="2411" name="_ErrorStop"><scope attributes="__ctor__" ilk="function" line="2408" lineend="2411" name="__init__" signature="_ErrorStop()"><variable attributes="kwargs" citdl="_ErrorStop" ilk="argument" line="2408" name="self" /></scope><variable attributes="__instancevar__" citdl="str" line="2410" name="name" /></scope><scope attributes="__ctor__" ilk="function" line="2413" lineend="2418" name="__init__" signature="And(exprs, savelist=True)"><variable citdl="And" ilk="argument" line="2413" name="self" /><variable ilk="argument" line="2413" name="exprs" /><variable citdl="True" ilk="argument" line="2413" name="savelist" /></scope><variable attributes="__instancevar__" citdl="all()" line="2415" name="mayReturnEmpty" /><variable attributes="__instancevar__" line="2417" name="skipWhitespace" /><variable attributes="__instancevar__" citdl="True" line="2418" name="callPreparse" /><scope ilk="function" line="2420" lineend="2443" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="And" ilk="argument" line="2420" name="self" /><variable ilk="argument" line="2420" name="instring" /><variable ilk="argument" line="2420" name="loc" /><variable citdl="True" ilk="argument" line="2420" name="doActions" /><variable line="2423" name="resultlist" /><variable citdl="False" line="2424" name="errorStop" /><variable line="2425" name="e" /><variable line="2431" name="exprtokens" /></scope><scope ilk="function" line="2445" lineend="2448" name="__iadd__" returns="self.append()" signature="__iadd__(other)"><variable citdl="And" ilk="argument" line="2445" name="self" /><variable citdl="Literal" ilk="argument" line="2445" name="other" /></scope><scope ilk="function" line="2450" lineend="2455" name="checkRecursion" signature="checkRecursion(parseElementList)"><variable citdl="And" ilk="argument" line="2450" name="self" /><variable ilk="argument" line="2450" name="parseElementList" /><variable line="2451" name="subRecCheckList" /><variable line="2452" name="e" /></scope><scope ilk="function" line="2457" lineend="2464" name="__str__" returns="self.name" signature="__str__()"><variable citdl="And" ilk="argument" line="2457" name="self" /></scope><variable attributes="__instancevar__" line="2462" name="strRepr" /></scope><scope classrefs="ParseExpression" doc="Requires that at least one C{ParseExpression} is found.&#10;If two expressions match, the expression that matches the longest string will be used.&#10;May be constructed using the C{'^'} operator." ilk="class" line="2467" lineend="2534" name="Or"><scope attributes="__ctor__" ilk="function" line="2472" lineend="2477" name="__init__" signature="Or(exprs, savelist=False)"><variable citdl="Or" ilk="argument" line="2472" name="self" /><variable ilk="argument" line="2472" name="exprs" /><variable citdl="False" ilk="argument" line="2472" name="savelist" /></scope><variable attributes="__instancevar__" citdl="any()" line="2475" name="mayReturnEmpty" /><scope ilk="function" line="2479" lineend="2514" name="parseImpl" returns="e._parse()" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="Or" ilk="argument" line="2479" name="self" /><variable ilk="argument" line="2479" name="instring" /><variable ilk="argument" line="2479" name="loc" /><variable citdl="True" ilk="argument" line="2479" name="doActions" /><variable citdl="err.loc" line="2480" name="maxExcLoc" /><variable citdl="err" line="2481" name="maxException" /><variable citdl="list" line="2482" name="matches" /><variable line="2483" name="e" /><variable citdl="e.tryParse()" line="2485" name="loc2" /><variable attributes="protected" line="2501" name="_" /></scope><scope ilk="function" line="2517" lineend="2520" name="__ixor__" returns="self.append()" signature="__ixor__(other)"><variable citdl="Or" ilk="argument" line="2517" name="self" /><variable citdl="ParserElement.literalStringClass()" ilk="argument" line="2517" name="other" /></scope><scope ilk="function" line="2522" lineend="2529" name="__str__" returns="self.name" signature="__str__()"><variable citdl="Or" ilk="argument" line="2522" name="self" /></scope><variable attributes="__instancevar__" line="2527" name="strRepr" /><scope ilk="function" line="2531" lineend="2534" name="checkRecursion" signature="checkRecursion(parseElementList)"><variable citdl="Or" ilk="argument" line="2531" name="self" /><variable ilk="argument" line="2531" name="parseElementList" /><variable line="2532" name="subRecCheckList" /><variable line="2533" name="e" /></scope></scope><scope classrefs="ParseExpression" doc="Requires that at least one C{ParseExpression} is found.&#10;If two expressions match, the first one listed is the one that will match.&#10;May be constructed using the C{'|'} operator." ilk="class" line="2537" lineend="2590" name="MatchFirst"><scope attributes="__ctor__" ilk="function" line="2542" lineend="2547" name="__init__" signature="MatchFirst(exprs, savelist=False)"><variable citdl="MatchFirst" ilk="argument" line="2542" name="self" /><variable ilk="argument" line="2542" name="exprs" /><variable citdl="False" ilk="argument" line="2542" name="savelist" /></scope><variable attributes="__instancevar__" citdl="any()" line="2545" name="mayReturnEmpty" /><scope ilk="function" line="2549" lineend="2571" name="parseImpl" returns="e._parse()" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="MatchFirst" ilk="argument" line="2549" name="self" /><variable ilk="argument" line="2549" name="instring" /><variable ilk="argument" line="2549" name="loc" /><variable citdl="True" ilk="argument" line="2549" name="doActions" /><variable citdl="int" line="2550" name="maxExcLoc" /><variable citdl="err" line="2551" name="maxException" /><variable line="2552" name="e" /><variable citdl="e._parse()" line="2554" name="ret" /></scope><scope ilk="function" line="2573" lineend="2576" name="__ior__" returns="self.append()" signature="__ior__(other)"><variable citdl="MatchFirst" ilk="argument" line="2573" name="self" /><variable citdl="ParserElement.literalStringClass()" ilk="argument" line="2573" name="other" /></scope><scope ilk="function" line="2578" lineend="2585" name="__str__" returns="self.name" signature="__str__()"><variable citdl="MatchFirst" ilk="argument" line="2578" name="self" /></scope><variable attributes="__instancevar__" line="2583" name="strRepr" /><scope ilk="function" line="2587" lineend="2590" name="checkRecursion" signature="checkRecursion(parseElementList)"><variable citdl="MatchFirst" ilk="argument" line="2587" name="self" /><variable ilk="argument" line="2587" name="parseElementList" /><variable line="2588" name="subRecCheckList" /><variable line="2589" name="e" /></scope></scope><scope classrefs="ParseExpression" doc="Requires all given C{ParseExpression}s to be found, but in any order.&#10;Expressions may be separated by whitespace.&#10;May be constructed using the C{'&amp;'} operator." ilk="class" line="2593" lineend="2673" name="Each"><scope attributes="__ctor__" ilk="function" line="2598" lineend="2602" name="__init__" signature="Each(exprs, savelist=True)"><variable citdl="Each" ilk="argument" line="2598" name="self" /><variable ilk="argument" line="2598" name="exprs" /><variable citdl="True" ilk="argument" line="2598" name="savelist" /></scope><variable attributes="__instancevar__" citdl="all()" line="2600" name="mayReturnEmpty" /><variable attributes="__instancevar__" citdl="True" line="2601" name="skipWhitespace" /><variable attributes="__instancevar__" citdl="False" line="2602" name="initExprGroups" /><scope ilk="function" line="2604" lineend="2659" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="Each" ilk="argument" line="2604" name="self" /><variable ilk="argument" line="2604" name="instring" /><variable ilk="argument" line="2604" name="loc" /><variable citdl="True" ilk="argument" line="2604" name="doActions" /><variable citdl="list" line="2607" name="opt1" /><variable citdl="list" line="2608" name="opt2" /><variable line="2615" name="tmpLoc" /><variable line="2616" name="tmpReqd" /><variable line="2617" name="tmpOpt" /><variable citdl="list" line="2618" name="matchOrder" /><variable citdl="False" line="2620" name="keepMatching" /><variable line="2622" name="tmpExprs" /><variable citdl="list" line="2623" name="failed" /><variable line="2624" name="e" /><variable citdl="__builtins__.str.join()" line="2637" name="missing" /><variable citdl="list" line="2643" name="resultlist" /><variable line="2645" name="results" /><variable citdl="ParseResults" line="2648" name="finalResults" /><variable line="2649" name="r" /><variable citdl="dict" line="2650" name="dups" /><variable line="2651" name="k" /><variable citdl="ParseResults" line="2653" name="tmp" /><variable line="2657" name="v" /></scope><variable attributes="__instancevar__" citdl="dict()" line="2606" name="opt1map" /><variable attributes="__instancevar__" line="2609" name="optionals" /><variable attributes="__instancevar__" citdl="list" line="2610" name="multioptionals" /><variable attributes="__instancevar__" citdl="list" line="2611" name="multirequired" /><variable attributes="__instancevar__" citdl="list" line="2612" name="required" /><scope ilk="function" line="2661" lineend="2668" name="__str__" returns="self.name" signature="__str__()"><variable citdl="Each" ilk="argument" line="2661" name="self" /></scope><variable attributes="__instancevar__" line="2666" name="strRepr" /><scope ilk="function" line="2670" lineend="2673" name="checkRecursion" signature="checkRecursion(parseElementList)"><variable citdl="Each" ilk="argument" line="2670" name="self" /><variable ilk="argument" line="2670" name="parseElementList" /><variable line="2671" name="subRecCheckList" /><variable line="2672" name="e" /></scope></scope><scope classrefs="ParserElement" doc="Abstract subclass of C{ParserElement}, for combining and post-processing parsed tokens." ilk="class" line="2676" lineend="2745" name="ParseElementEnhance"><scope attributes="__ctor__" ilk="function" line="2678" lineend="2691" name="__init__" signature="ParseElementEnhance(expr, savelist=False)"><variable citdl="ParseElementEnhance" ilk="argument" line="2678" name="self" /><variable citdl="Literal" ilk="argument" line="2678" name="expr" /><variable citdl="False" ilk="argument" line="2678" name="savelist" /></scope><variable attributes="__instancevar__" citdl="self.expr.copy()" line="2682" name="expr" /><variable attributes="__instancevar__" line="2683" name="strRepr" /><variable attributes="__instancevar__" citdl="expr.mayIndexError" line="2685" name="mayIndexError" /><variable attributes="__instancevar__" citdl="expr.mayReturnEmpty" line="2686" name="mayReturnEmpty" /><variable attributes="__instancevar__" citdl="False" line="2688" name="skipWhitespace" /><variable attributes="__instancevar__" citdl="expr.saveAsList" line="2689" name="saveAsList" /><variable attributes="__instancevar__" citdl="expr.callPreparse" line="2690" name="callPreparse" /><scope ilk="function" line="2693" lineend="2697" name="parseImpl" returns="self.expr._parse()" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="ParseElementEnhance" ilk="argument" line="2693" name="self" /><variable ilk="argument" line="2693" name="instring" /><variable ilk="argument" line="2693" name="loc" /><variable citdl="True" ilk="argument" line="2693" name="doActions" /></scope><scope ilk="function" line="2699" lineend="2704" name="leaveWhitespace" returns="ParseElementEnhance" signature="leaveWhitespace()"><variable citdl="ParseElementEnhance" ilk="argument" line="2699" name="self" /></scope><scope ilk="function" line="2706" lineend="2716" name="ignore" returns="ParseElementEnhance" signature="ignore(other)"><variable citdl="ParseElementEnhance" ilk="argument" line="2706" name="self" /><variable ilk="argument" line="2706" name="other" /></scope><scope ilk="function" line="2718" lineend="2722" name="streamline" returns="ParseElementEnhance" signature="streamline()"><variable citdl="ParseElementEnhance" ilk="argument" line="2718" name="self" /></scope><scope ilk="function" line="2724" lineend="2729" name="checkRecursion" signature="checkRecursion(parseElementList)"><variable citdl="ParseElementEnhance" ilk="argument" line="2724" name="self" /><variable ilk="argument" line="2724" name="parseElementList" /><variable line="2727" name="subRecCheckList" /></scope><scope ilk="function" line="2731" lineend="2735" name="validate" signature="validate(validateTrace=[])"><variable citdl="ParseElementEnhance" ilk="argument" line="2731" name="self" /><variable citdl="list" ilk="argument" line="2731" name="validateTrace" /><variable line="2732" name="tmp" /></scope><scope ilk="function" line="2737" lineend="2745" name="__str__" signature="__str__()"><variable citdl="ParseElementEnhance" ilk="argument" line="2737" name="self" /></scope></scope><scope classrefs="ParseElementEnhance" doc="Lookahead matching of the given parse expression.  C{FollowedBy}&#10;does *not* advance the parsing position within the input string, it only&#10;verifies that the specified parse expression matches at the current&#10;position.  C{FollowedBy} always returns a null token list." ilk="class" line="2748" lineend="2759" name="FollowedBy"><scope attributes="__ctor__" ilk="function" line="2753" lineend="2755" name="__init__" signature="FollowedBy(expr)"><variable citdl="FollowedBy" ilk="argument" line="2753" name="self" /><variable ilk="argument" line="2753" name="expr" /></scope><variable attributes="__instancevar__" citdl="True" line="2755" name="mayReturnEmpty" /><scope ilk="function" line="2757" lineend="2759" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="FollowedBy" ilk="argument" line="2757" name="self" /><variable ilk="argument" line="2757" name="instring" /><variable ilk="argument" line="2757" name="loc" /><variable citdl="True" ilk="argument" line="2757" name="doActions" /></scope></scope><scope classrefs="ParseElementEnhance" doc="Lookahead to disallow matching with the given parse expression.  C{NotAny}&#10;does *not* advance the parsing position within the input string, it only&#10;verifies that the specified parse expression does *not* match at the current&#10;position.  Also, C{NotAny} does *not* skip over leading whitespace. C{NotAny}&#10;always returns a null token list.  May be constructed using the '~' operator." ilk="class" line="2762" lineend="2787" name="NotAny"><scope attributes="__ctor__" ilk="function" line="2768" lineend="2773" name="__init__" signature="NotAny(expr)"><variable citdl="NotAny" ilk="argument" line="2768" name="self" /><variable ilk="argument" line="2768" name="expr" /></scope><variable attributes="__instancevar__" citdl="False" line="2771" name="skipWhitespace" /><variable attributes="__instancevar__" citdl="True" line="2772" name="mayReturnEmpty" /><variable attributes="__instancevar__" line="2773" name="errmsg" /><scope ilk="function" line="2775" lineend="2778" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="NotAny" ilk="argument" line="2775" name="self" /><variable ilk="argument" line="2775" name="instring" /><variable ilk="argument" line="2775" name="loc" /><variable citdl="True" ilk="argument" line="2775" name="doActions" /></scope><scope ilk="function" line="2780" lineend="2787" name="__str__" returns="self.name" signature="__str__()"><variable citdl="NotAny" ilk="argument" line="2780" name="self" /></scope><variable attributes="__instancevar__" line="2785" name="strRepr" /></scope><scope classrefs="ParseElementEnhance" doc="Repetition of one or more of the given expression.&#10;&#10;Parameters:&#10; - expr - expression that must match one or more times&#10; - stopOn - (default=None) - expression for a terminating sentinel&#10;   (only required if the sentinel would ordinarily match the repetition &#10;   expression)          " ilk="class" line="2790" lineend="2847" name="OneOrMore"><scope attributes="__ctor__" ilk="function" line="2799" lineend="2804" name="__init__" signature="OneOrMore(expr, stopOn=None)"><variable citdl="OneOrMore" ilk="argument" line="2799" name="self" /><variable ilk="argument" line="2799" name="expr" /><variable ilk="argument" line="2799" name="stopOn" /><variable citdl="Literal" line="2801" name="ender" /></scope><variable attributes="__instancevar__" line="2804" name="not_ender" /><scope ilk="function" line="2806" lineend="2833" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="OneOrMore" ilk="argument" line="2806" name="self" /><variable ilk="argument" line="2806" name="instring" /><variable ilk="argument" line="2806" name="loc" /><variable citdl="True" ilk="argument" line="2806" name="doActions" /><variable citdl="self.expr._parse" line="2807" name="self_expr_parse" /><variable citdl="self._skipIgnorables" line="2808" name="self_skip_ignorables" /><variable citdl="bool" line="2809" name="check_ender" /><variable citdl="self.not_ender.tryParse" line="2811" name="try_not_ender" /><variable line="2817" name="tokens" /><variable citdl="self.ignoreExprs" line="2819" name="hasIgnoreExprs" /><variable citdl="self_skip_ignorables()" line="2824" name="preloc" /><variable line="2827" name="tmptokens" /></scope><scope ilk="function" line="2835" lineend="2842" name="__str__" returns="self.name" signature="__str__()"><variable citdl="OneOrMore" ilk="argument" line="2835" name="self" /></scope><variable attributes="__instancevar__" line="2840" name="strRepr" /><scope ilk="function" line="2844" lineend="2847" name="setResultsName" signature="setResultsName(name, listAllMatches=False)"><variable citdl="OneOrMore" ilk="argument" line="2844" name="self" /><variable ilk="argument" line="2844" name="name" /><variable citdl="False" ilk="argument" line="2844" name="listAllMatches" /><variable line="2845" name="ret" /></scope></scope><scope classrefs="OneOrMore" doc="Optional repetition of zero or more of the given expression.&#10;&#10;Parameters:&#10; - expr - expression that must match zero or more times&#10; - stopOn - (default=None) - expression for a terminating sentinel&#10;   (only required if the sentinel would ordinarily match the repetition &#10;   expression)          " ilk="class" line="2849" lineend="2875" name="ZeroOrMore"><scope attributes="__ctor__" ilk="function" line="2858" lineend="2860" name="__init__" signature="ZeroOrMore(expr, stopOn=None)"><variable citdl="ZeroOrMore" ilk="argument" line="2858" name="self" /><variable ilk="argument" line="2858" name="expr" /><variable ilk="argument" line="2858" name="stopOn" /></scope><variable attributes="__instancevar__" citdl="True" line="2860" name="mayReturnEmpty" /><scope ilk="function" line="2862" lineend="2866" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="ZeroOrMore" ilk="argument" line="2862" name="self" /><variable ilk="argument" line="2862" name="instring" /><variable ilk="argument" line="2862" name="loc" /><variable citdl="True" ilk="argument" line="2862" name="doActions" /></scope><scope ilk="function" line="2868" lineend="2875" name="__str__" returns="self.name" signature="__str__()"><variable citdl="ZeroOrMore" ilk="argument" line="2868" name="self" /></scope><variable attributes="__instancevar__" line="2873" name="strRepr" /></scope><scope attributes="protected" classrefs="object" ilk="class" line="2877" lineend="2882" name="_NullToken"><scope ilk="function" line="2878" lineend="2879" name="__bool__" returns="bool" signature="__bool__()"><variable citdl="_NullToken" ilk="argument" line="2878" name="self" /></scope><variable citdl="_NullToken.__bool__" line="2880" name="__nonzero__" /><scope ilk="function" line="2881" lineend="2882" name="__str__" returns="str" signature="__str__()"><variable citdl="_NullToken" ilk="argument" line="2881" name="self" /></scope></scope><variable attributes="protected" citdl="_NullToken" line="2884" name="_optionalNotMatched" /><scope classrefs="ParseElementEnhance" doc="Optional matching of the given expression.&#10;&#10;Parameters:&#10; - expr - expression that must match zero or more times&#10; - default (optional) - value to be returned if the optional expression&#10;   is not found." ilk="class" line="2885" lineend="2919" name="Optional"><scope attributes="__ctor__" ilk="function" line="2893" lineend="2896" name="__init__" signature="Optional(expr, default=_optionalNotMatched)"><variable citdl="Optional" ilk="argument" line="2893" name="self" /><variable ilk="argument" line="2893" name="expr" /><variable citdl="_NullToken" ilk="argument" line="2893" name="default" /></scope><variable attributes="__instancevar__" citdl="_NullToken" line="2895" name="defaultValue" /><variable attributes="__instancevar__" citdl="True" line="2896" name="mayReturnEmpty" /><scope ilk="function" line="2898" lineend="2910" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="Optional" ilk="argument" line="2898" name="self" /><variable ilk="argument" line="2898" name="instring" /><variable ilk="argument" line="2898" name="loc" /><variable citdl="True" ilk="argument" line="2898" name="doActions" /><variable citdl="list" line="2900" name="tokens" /></scope><scope ilk="function" line="2912" lineend="2919" name="__str__" returns="self.name" signature="__str__()"><variable citdl="Optional" ilk="argument" line="2912" name="self" /></scope><variable attributes="__instancevar__" line="2917" name="strRepr" /></scope><scope classrefs="ParseElementEnhance" doc="Token for skipping over all undefined text until the matched expression is found.&#10;&#10;Parameters:&#10; - expr - target expression marking the end of the data to be skipped&#10; - include - (default=False) if True, the target expression is also parsed &#10;   (the skipped text and target expression are returned as a 2-element list).&#10; - ignore - (default=None) used to define grammars (typically quoted strings and &#10;   comments) that might contain false matches to the target expression&#10; - failOn - (default=None) define expressions that are not allowed to be &#10;   included in the skipped test; if found before the target expression is found, &#10;   the SkipTo is not a match" ilk="class" line="2921" lineend="2992" name="SkipTo"><scope attributes="__ctor__" ilk="function" line="2934" lineend="2945" name="__init__" signature="SkipTo(other, include=False, ignore=None, failOn=None)"><variable citdl="SkipTo" ilk="argument" line="2934" name="self" /><variable ilk="argument" line="2934" name="other" /><variable citdl="False" ilk="argument" line="2934" name="include" /><variable ilk="argument" line="2934" name="ignore" /><variable ilk="argument" line="2934" name="failOn" /></scope><variable attributes="__instancevar__" line="2936" name="ignoreExpr" /><variable attributes="__instancevar__" citdl="True" line="2937" name="mayReturnEmpty" /><variable attributes="__instancevar__" citdl="False" line="2938" name="mayIndexError" /><variable attributes="__instancevar__" citdl="False" line="2939" name="includeMatch" /><variable attributes="__instancevar__" citdl="False" line="2940" name="asList" /><variable attributes="__instancevar__" citdl="Literal" line="2942" name="failOn" /><variable attributes="__instancevar__" line="2945" name="errmsg" /><scope ilk="function" line="2947" lineend="2992" name="parseImpl" returns="tuple" signature="parseImpl(instring, loc, doActions=True)"><variable citdl="SkipTo" ilk="argument" line="2947" name="self" /><variable ilk="argument" line="2947" name="instring" /><variable citdl="self_ignoreExpr_tryParse()" ilk="argument" line="2947" name="loc" /><variable citdl="True" ilk="argument" line="2947" name="doActions" /><variable line="2948" name="startloc" /><variable citdl="len()" line="2949" name="instrlen" /><variable citdl="self.expr" line="2950" name="expr" /><variable citdl="self.expr._parse" line="2951" name="expr_parse" /><variable line="2952" name="self_failOn_canParseNext" /><variable line="2953" name="self_ignoreExpr_tryParse" /><variable citdl="self_ignoreExpr_tryParse()" line="2955" name="tmploc" /><variable line="2985" name="skiptext" /><variable citdl="ParseResults" line="2986" name="skipresult" /><variable line="2989" name="mat" /></scope></scope><scope classrefs="ParseElementEnhance" doc="Forward declaration of an expression to be defined later -&#10;used for recursive grammars, such as algebraic infix notation.&#10;When the expression is known, it is assigned to the C{Forward} variable using the '&lt;&lt;' operator.&#10;&#10;Note: take care when assigning to C{Forward} not to overlook precedence of operators.&#10;Specifically, '|' has a lower precedence than '&lt;&lt;', so that::&#10;   fwdExpr &lt;&lt; a | b | c&#10;will actually be evaluated as::&#10;   (fwdExpr &lt;&lt; a) | b | c&#10;thereby leaving b and c out as parseable alternatives.  It is recommended that you&#10;explicitly group the values inserted into the C{Forward}::&#10;   fwdExpr &lt;&lt; (a | b | c)&#10;Converting to use the '&lt;&lt;=' operator instead will avoid this problem." ilk="class" line="2994" lineend="3069" name="Forward"><scope attributes="__ctor__" ilk="function" line="3009" lineend="3010" name="__init__" signature="Forward(other=None)"><variable citdl="Forward" ilk="argument" line="3009" name="self" /><variable ilk="argument" line="3009" name="other" /></scope><scope ilk="function" line="3012" lineend="3023" name="__lshift__" returns="Forward" signature="__lshift__(other)"><variable citdl="Forward" ilk="argument" line="3012" name="self" /><variable citdl="ParserElement.literalStringClass()" ilk="argument" line="3012" name="other" /></scope><variable attributes="__instancevar__" citdl="ParserElement.literalStringClass()" line="3015" name="expr" /><variable attributes="__instancevar__" line="3016" name="strRepr" /><variable attributes="__instancevar__" citdl="self.expr.mayIndexError" line="3017" name="mayIndexError" /><variable attributes="__instancevar__" citdl="self.expr.mayReturnEmpty" line="3018" name="mayReturnEmpty" /><variable attributes="__instancevar__" citdl="False" line="3020" name="skipWhitespace" /><variable attributes="__instancevar__" citdl="self.expr.saveAsList" line="3021" name="saveAsList" /><scope ilk="function" line="3025" lineend="3026" name="__ilshift__" returns="int" signature="__ilshift__(other)"><variable citdl="Forward" ilk="argument" line="3025" name="self" /><variable ilk="argument" line="3025" name="other" /></scope><scope ilk="function" line="3028" lineend="3030" name="leaveWhitespace" returns="Forward" signature="leaveWhitespace()"><variable citdl="Forward" ilk="argument" line="3028" name="self" /></scope><scope ilk="function" line="3032" lineend="3037" name="streamline" returns="Forward" signature="streamline()"><variable citdl="Forward" ilk="argument" line="3032" name="self" /></scope><variable attributes="__instancevar__" citdl="True" line="3034" name="streamlined" /><scope ilk="function" line="3039" lineend="3044" name="validate" signature="validate(validateTrace=[])"><variable citdl="Forward" ilk="argument" line="3039" name="self" /><variable citdl="list" ilk="argument" line="3039" name="validateTrace" /><variable line="3041" name="tmp" /></scope><scope ilk="function" line="3046" lineend="3061" name="__str__" returns="self.name" signature="__str__()"><variable citdl="Forward" ilk="argument" line="3046" name="self" /><variable citdl="str" line="3056" name="retString" /></scope><variable attributes="protected __instancevar__" citdl="self.__class__" line="3052" name="_revertClass" /><variable attributes="__instancevar__" citdl="_ForwardNoRecurse" line="3053" name="__class__" /><scope ilk="function" line="3063" lineend="3069" name="copy" signature="copy()"><variable citdl="Forward" ilk="argument" line="3063" name="self" /><variable citdl="" line="3067" name="ret" /></scope></scope><scope attributes="protected" classrefs="Forward" ilk="class" line="3071" lineend="3073" name="_ForwardNoRecurse"><scope ilk="function" line="3072" lineend="3073" name="__str__" returns="str" signature="__str__()"><variable citdl="_ForwardNoRecurse" ilk="argument" line="3072" name="self" /></scope></scope><scope classrefs="ParseElementEnhance" doc="Abstract subclass of C{ParseExpression}, for converting parsed results." ilk="class" line="3075" lineend="3079" name="TokenConverter"><scope attributes="__ctor__" ilk="function" line="3077" lineend="3079" name="__init__" signature="TokenConverter(expr, savelist=False)"><variable citdl="TokenConverter" ilk="argument" line="3077" name="self" /><variable ilk="argument" line="3077" name="expr" /><variable citdl="False" ilk="argument" line="3077" name="savelist" /></scope><variable attributes="__instancevar__" citdl="False" line="3079" name="saveAsList" /></scope><scope classrefs="TokenConverter" doc="Converter to concatenate all matching tokens to a single string.&#10;By default, the matching patterns must also be contiguous in the input string;&#10;this can be disabled by specifying C{'adjacent=False'} in the constructor." ilk="class" line="3081" lineend="3111" name="Combine"><scope attributes="__ctor__" ilk="function" line="3086" lineend="3094" name="__init__" signature="Combine(expr, joinString='', adjacent=True)"><variable citdl="Combine" ilk="argument" line="3086" name="self" /><variable ilk="argument" line="3086" name="expr" /><variable citdl="str" ilk="argument" line="3086" name="joinString" /><variable citdl="True" ilk="argument" line="3086" name="adjacent" /></scope><variable attributes="__instancevar__" citdl="True" line="3091" name="adjacent" /><variable attributes="__instancevar__" citdl="True" line="3092" name="skipWhitespace" /><variable attributes="__instancevar__" citdl="str" line="3093" name="joinString" /><variable attributes="__instancevar__" citdl="True" line="3094" name="callPreparse" /><scope ilk="function" line="3096" lineend="3101" name="ignore" returns="Combine" signature="ignore(other)"><variable citdl="Combine" ilk="argument" line="3096" name="self" /><variable ilk="argument" line="3096" name="other" /></scope><scope ilk="function" line="3103" lineend="3111" name="postParse" returns="list" signature="postParse(instring, loc, tokenlist)"><variable citdl="Combine" ilk="argument" line="3103" name="self" /><variable ilk="argument" line="3103" name="instring" /><variable ilk="argument" line="3103" name="loc" /><variable ilk="argument" line="3103" name="tokenlist" /><variable citdl="tokenlist.copy()" line="3104" name="retToks" /></scope></scope><scope classrefs="TokenConverter" doc="Converter to return the matched tokens as a list - useful for returning tokens of C{L{ZeroOrMore}} and C{L{OneOrMore}} expressions." ilk="class" line="3113" lineend="3120" name="Group"><scope attributes="__ctor__" ilk="function" line="3115" lineend="3117" name="__init__" signature="Group(expr)"><variable citdl="Group" ilk="argument" line="3115" name="self" /><variable ilk="argument" line="3115" name="expr" /></scope><variable attributes="__instancevar__" citdl="True" line="3117" name="saveAsList" /><scope ilk="function" line="3119" lineend="3120" name="postParse" returns="list" signature="postParse(instring, loc, tokenlist)"><variable citdl="Group" ilk="argument" line="3119" name="self" /><variable ilk="argument" line="3119" name="instring" /><variable ilk="argument" line="3119" name="loc" /><variable ilk="argument" line="3119" name="tokenlist" /></scope></scope><scope classrefs="TokenConverter" doc="Converter to return a repetitive expression as a list, but also as a dictionary.&#10;Each element can also be referenced using the first token in the expression as its key.&#10;Useful for tabular report scraping when the first column can be used as a item key." ilk="class" line="3122" lineend="3153" name="Dict"><scope attributes="__ctor__" ilk="function" line="3127" lineend="3129" name="__init__" signature="Dict(expr)"><variable citdl="Dict" ilk="argument" line="3127" name="self" /><variable ilk="argument" line="3127" name="expr" /></scope><variable attributes="__instancevar__" citdl="True" line="3129" name="saveAsList" /><scope ilk="function" line="3131" lineend="3153" name="postParse" returns="list" signature="postParse(instring, loc, tokenlist)"><variable citdl="Dict" ilk="argument" line="3131" name="self" /><variable ilk="argument" line="3131" name="instring" /><variable ilk="argument" line="3131" name="loc" /><variable ilk="argument" line="3131" name="tokenlist" /><variable line="3132" name="tok" /><variable line="3132" name="i" /><variable line="3135" name="ikey" /><variable citdl="tok.copy()" line="3143" name="dictvalue" /></scope></scope><scope classrefs="TokenConverter" doc="Converter for ignoring the results of a parsed expression." ilk="class" line="3156" lineend="3162" name="Suppress"><scope ilk="function" line="3158" lineend="3159" name="postParse" returns="list" signature="postParse(instring, loc, tokenlist)"><variable citdl="Suppress" ilk="argument" line="3158" name="self" /><variable ilk="argument" line="3158" name="instring" /><variable ilk="argument" line="3158" name="loc" /><variable ilk="argument" line="3158" name="tokenlist" /></scope><scope ilk="function" line="3161" lineend="3162" name="suppress" returns="Suppress" signature="suppress()"><variable citdl="Suppress" ilk="argument" line="3161" name="self" /></scope></scope><scope classrefs="object" doc="Wrapper for parse actions, to ensure they are only called once." ilk="class" line="3165" lineend="3177" name="OnlyOnce"><scope attributes="__ctor__" ilk="function" line="3167" lineend="3169" name="__init__" signature="OnlyOnce(methodCall)"><variable citdl="OnlyOnce" ilk="argument" line="3167" name="self" /><variable ilk="argument" line="3167" name="methodCall" /></scope><variable attributes="__instancevar__" citdl="_trim_arity()" line="3168" name="callable" /><variable attributes="__instancevar__" citdl="False" line="3169" name="called" /><scope ilk="function" line="3170" lineend="3175" name="__call__" returns="callable()" signature="__call__(s, l, t)"><variable citdl="OnlyOnce" ilk="argument" line="3170" name="self" /><variable ilk="argument" line="3170" name="s" /><variable ilk="argument" line="3170" name="l" /><variable ilk="argument" line="3170" name="t" /><variable citdl="callable()" line="3172" name="results" /></scope><scope ilk="function" line="3176" lineend="3177" name="reset" signature="reset()"><variable citdl="OnlyOnce" ilk="argument" line="3176" name="self" /></scope></scope><scope doc="Decorator for debugging parse actions." ilk="function" line="3179" lineend="3199" name="traceParseAction" returns="traceParseAction.z" signature="traceParseAction(f)"><variable citdl="_trim_arity()" ilk="argument" line="3179" name="f" /><scope ilk="function" line="3182" lineend="3194" name="z" returns="f()" signature="z()"><variable citdl="f.func_name" line="3183" name="thisFunc" /><variable citdl="f()" line="3189" name="ret" /><variable citdl="f.__name__" line="3196" name="__name__" /></scope></scope><scope doc="Helper to define a delimited list of expressions - the delimiter defaults to ','.&#10;By default, the list elements and delimiters can have intervening whitespace, and&#10;comments, but this can be overridden by passing C{combine=True} in the constructor.&#10;If C{combine} is set to C{True}, the matching tokens are returned as a single token&#10;string, with the delimiters included; otherwise, the matching tokens are returned&#10;as a list of tokens, with the delimiters suppressed." ilk="function" line="3204" lineend="3216" name="delimitedList" signature="delimitedList(expr, delim=',', combine=False)"><variable ilk="argument" line="3204" name="expr" /><variable citdl="str" ilk="argument" line="3204" name="delim" /><variable citdl="False" ilk="argument" line="3204" name="combine" /><variable line="3212" name="dlName" /></scope><scope doc="Helper to define a counted list of expressions.&#10;This helper defines a pattern of the form::&#10;    integer expr expr expr...&#10;where the leading integer tells how many expr expressions follow.&#10;The matched tokens returns the array of expr tokens as a list - the leading count token is suppressed." ilk="function" line="3218" lineend="3236" name="countedArray" signature="countedArray(expr, intExpr=None)"><variable ilk="argument" line="3218" name="expr" /><variable citdl="intExpr.copy()" ilk="argument" line="3218" name="intExpr" /><variable citdl="Forward" line="3225" name="arrayExpr" /><scope ilk="function" line="3226" lineend="3229" name="countFieldParseAction" returns="list" signature="countFieldParseAction(s, l, t)"><variable ilk="argument" line="3226" name="s" /><variable ilk="argument" line="3226" name="l" /><variable ilk="argument" line="3226" name="t" /><variable line="3227" name="n" /></scope></scope><scope attributes="protected" ilk="function" line="3238" lineend="3245" name="_flatten" returns="list" signature="_flatten(L)"><variable ilk="argument" line="3238" name="L" /><variable citdl="list" line="3239" name="ret" /><variable line="3240" name="i" /></scope><scope doc="Helper to define an expression that is indirectly defined from&#10;the tokens matched in a previous expression, that is, it looks&#10;for a 'repeat' of a previous expression.  For example::&#10;    first = Word(nums)&#10;    second = matchPreviousLiteral(first)&#10;    matchExpr = first + &quot;:&quot; + second&#10;will match C{&quot;1:1&quot;}, but not C{&quot;1:2&quot;}.  Because this matches a&#10;previous literal, will also match the leading C{&quot;1:1&quot;} in C{&quot;1:10&quot;}.&#10;If this is not desired, use C{matchPreviousExpr}.&#10;Do *not* use with packrat parsing enabled." ilk="function" line="3247" lineend="3272" name="matchPreviousLiteral" returns="Forward" signature="matchPreviousLiteral(expr)"><variable ilk="argument" line="3247" name="expr" /><variable citdl="Forward" line="3259" name="rep" /><scope ilk="function" line="3260" lineend="3269" name="copyTokenToRepeater" signature="copyTokenToRepeater(s, l, t)"><variable ilk="argument" line="3260" name="s" /><variable ilk="argument" line="3260" name="l" /><variable ilk="argument" line="3260" name="t" /><variable citdl="_flatten()" line="3266" name="tflat" /></scope></scope><scope doc="Helper to define an expression that is indirectly defined from&#10;the tokens matched in a previous expression, that is, it looks&#10;for a 'repeat' of a previous expression.  For example::&#10;    first = Word(nums)&#10;    second = matchPreviousExpr(first)&#10;    matchExpr = first + &quot;:&quot; + second&#10;will match C{&quot;1:1&quot;}, but not C{&quot;1:2&quot;}.  Because this matches by&#10;expressions, will *not* match the leading C{&quot;1:1&quot;} in C{&quot;1:10&quot;};&#10;the expressions are evaluated first, and then compared, so&#10;C{&quot;1&quot;} is compared with C{&quot;10&quot;}.&#10;Do *not* use with packrat parsing enabled." ilk="function" line="3274" lineend="3299" name="matchPreviousExpr" returns="Forward" signature="matchPreviousExpr(expr)"><variable ilk="argument" line="3274" name="expr" /><variable citdl="Forward" line="3287" name="rep" /><variable citdl="expr.copy()" line="3288" name="e2" /><scope ilk="function" line="3290" lineend="3296" name="copyTokenToRepeater" signature="copyTokenToRepeater(s, l, t)"><variable ilk="argument" line="3290" name="s" /><variable ilk="argument" line="3290" name="l" /><variable ilk="argument" line="3290" name="t" /><variable citdl="_flatten()" line="3291" name="matchTokens" /><scope ilk="function" line="3292" lineend="3295" name="mustMatchTheseTokens" signature="mustMatchTheseTokens(s, l, t)"><variable ilk="argument" line="3292" name="s" /><variable ilk="argument" line="3292" name="l" /><variable ilk="argument" line="3292" name="t" /><variable citdl="_flatten()" line="3293" name="theseTokens" /></scope></scope></scope><scope attributes="protected" ilk="function" line="3301" lineend="3307" name="_escapeRegexRangeChars" returns="_ustr()" signature="_escapeRegexRangeChars(s)"><variable citdl="s.replace()" ilk="argument" line="3301" name="s" /><variable line="3303" name="c" /></scope><scope doc="Helper to quickly define a set of alternative Literals, and makes sure to do&#10;longest-first testing when there is a conflict, regardless of the input order,&#10;but returns a C{L{MatchFirst}} for best performance.&#10;&#10;Parameters:&#10; - strs - a string of space-delimited literals, or a list of string literals&#10; - caseless - (default=False) - treat all literals as caseless&#10; - useRegex - (default=True) - as an optimization, will generate a Regex&#10;   object; otherwise, will generate a C{MatchFirst} object (if C{caseless=True}, or&#10;   if creating a C{Regex} raises an exception)" ilk="function" line="3309" lineend="3371" name="oneOf" returns="NoMatch" signature="oneOf(strs, caseless=False, useRegex=True)"><variable ilk="argument" line="3309" name="strs" /><variable citdl="False" ilk="argument" line="3309" name="caseless" /><variable citdl="True" ilk="argument" line="3309" name="useRegex" /><variable line="3322" name="isequal" /><variable line="3323" name="masks" /><variable citdl="CaselessLiteral" line="3324" name="parseElementClass" /><variable citdl="list()" line="3330" name="symbols" /><variable citdl="int" line="3343" name="i" /><variable line="3345" name="cur" /><variable line="3346" name="j" /><variable line="3346" name="other" /></scope><scope doc="Helper to easily and clearly define a dictionary by specifying the respective patterns&#10;for the key and value.  Takes care of defining the C{L{Dict}}, C{L{ZeroOrMore}}, and C{L{Group}} tokens&#10;in the proper order.  The key pattern can include delimiting markers or punctuation,&#10;as int as they are suppressed, thereby leaving the significant key text.  The value&#10;pattern can include named results, so that the C{Dict} results can include named token&#10;fields." ilk="function" line="3373" lineend="3381" name="dictOf" returns="Dict" signature="dictOf(key, value)"><variable ilk="argument" line="3373" name="key" /><variable ilk="argument" line="3373" name="value" /></scope><scope doc="Helper to return the original, untokenized text for a given expression.  Useful to&#10;restore the parsed fields of an HTML start tag into the raw tag text itself, or to&#10;revert separate tokens with intervening whitespace back to the original matching&#10;input text. By default, returns astring containing the original parsed text.  &#10;&#10;If the optional C{asString} argument is passed as C{False}, then the return value is a &#10;C{L{ParseResults}} containing any results names that were originally matched, and a &#10;single token containing the original matched text from the input string.  So if &#10;the expression passed to C{L{originalTextFor}} contains expressions with defined&#10;results names, you must set C{asString} to C{False} if you want to preserve those&#10;results name values." ilk="function" line="3383" lineend="3408" name="originalTextFor" signature="originalTextFor(expr, asString=True)"><variable ilk="argument" line="3383" name="expr" /><variable citdl="True" ilk="argument" line="3383" name="asString" /><variable line="3395" name="locMarker" /><variable citdl="locMarker.copy()" line="3396" name="endlocMarker" /><variable line="3398" name="matchExpr" /><scope ilk="function" line="3402" lineend="3406" name="extractText" signature="extractText(s, l, t)"><variable ilk="argument" line="3402" name="s" /><variable ilk="argument" line="3402" name="l" /><variable ilk="argument" line="3402" name="t" /></scope></scope><scope doc="Helper to undo pyparsing's default grouping of And expressions, even&#10;if all but one are non-empty." ilk="function" line="3410" lineend="3413" name="ungroup" signature="ungroup(expr)"><variable ilk="argument" line="3410" name="expr" /></scope><scope doc="Helper to decorate a returned token with its starting and ending locations in the input string.&#10;This helper adds the following results names:&#10; - locn_start = location where matched expression begins&#10; - locn_end = location where matched expression ends&#10; - value = the actual parsed results&#10;&#10;Be careful if the input text contains C{&lt;TAB&gt;} characters, you may want to call&#10;C{L{ParserElement.parseWithTabs}}" ilk="function" line="3415" lineend="3426" name="locatedExpr" returns="Group" signature="locatedExpr(expr)"><variable ilk="argument" line="3415" name="expr" /><variable line="3425" name="locator" /></scope><variable line="3430" name="empty" /><variable line="3431" name="lineStart" /><variable line="3432" name="lineEnd" /><variable line="3433" name="stringStart" /><variable line="3434" name="stringEnd" /><variable attributes="protected" line="3436" name="_escapedPunc" /><variable attributes="protected" line="3437" name="_escapedHexChar" /><variable attributes="protected" line="3438" name="_escapedOctChar" /><variable attributes="protected" citdl="int" line="3439" name="_singleChar" /><variable attributes="protected" citdl="Group" line="3440" name="_charRange" /><variable attributes="protected" line="3441" name="_reBracketExpr" /><scope doc="Helper to easily define string ranges for use in Word construction.  Borrows&#10;syntax from regexp '[]' string range definitions::&#10;   srange(&quot;[0-9]&quot;)   -&gt; &quot;0o123456789&quot;&#10;   srange(&quot;[a-z]&quot;)   -&gt; &quot;abcdefghijklmnopqrstuvwxyz&quot;&#10;   srange(&quot;[a-z$_]&quot;) -&gt; &quot;abcdefghijklmnopqrstuvwxyz$_&quot;&#10;The input string must be enclosed in []'s, and the returned string is the expanded&#10;character set joined into a single string.&#10;The values enclosed in the []'s may be::&#10;   a single character&#10;   an escaped character with a leading backslash (such as \- or \])&#10;   an escaped hex character with a leading '\x' (\x21, which is a '!' character) &#10;     (\0x## is also supported for backwards compatibility) &#10;   an escaped octal character with a leading '\0' (\0o41, which is a '!' character)&#10;   a range of any of the above, separated by a dash ('a-z', etc.)&#10;   any combination of the above ('aeiouy', 'a-zA-Z0-9_$', etc.)" ilk="function" line="3443" lineend="3464" name="srange" returns="__builtins__.str.join()" signature="srange(s)"><variable ilk="argument" line="3443" name="s" /><variable attributes="protected" line="3460" name="_expanded" /></scope><scope doc="Helper method for defining parse actions that require matching at a specific&#10;column in the input text." ilk="function" line="3466" lineend="3473" name="matchOnlyAtCol" returns="matchOnlyAtCol.verifyCol" signature="matchOnlyAtCol(n)"><variable ilk="argument" line="3466" name="n" /><scope ilk="function" line="3470" lineend="3472" name="verifyCol" signature="verifyCol(strg, locn, toks)"><variable ilk="argument" line="3470" name="strg" /><variable ilk="argument" line="3470" name="locn" /><variable ilk="argument" line="3470" name="toks" /></scope></scope><scope doc="Helper method for common parse actions that simply return a literal value.  Especially&#10;useful when used with C{L{transformString&lt;ParserElement.transformString&gt;}()}." ilk="function" line="3475" lineend="3482" name="replaceWith" returns="functools.partial()" signature="replaceWith(replStr)"><variable ilk="argument" line="3475" name="replStr" /></scope><scope doc="Helper parse action for removing quotation marks from parsed quoted strings.&#10;To use, add this parse action to quoted string using::&#10;  quotedString.setParseAction( removeQuotes )" ilk="function" line="3484" lineend="3489" name="removeQuotes" signature="removeQuotes(s, l, t)"><variable ilk="argument" line="3484" name="s" /><variable ilk="argument" line="3484" name="l" /><variable ilk="argument" line="3484" name="t" /></scope><scope doc="Helper parse action to convert tokens to upper case." ilk="function" line="3491" lineend="3493" name="upcaseTokens" returns="list" signature="upcaseTokens(s, l, t)"><variable ilk="argument" line="3491" name="s" /><variable ilk="argument" line="3491" name="l" /><variable ilk="argument" line="3491" name="t" /></scope><scope doc="Helper parse action to convert tokens to lower case." ilk="function" line="3495" lineend="3497" name="downcaseTokens" returns="list" signature="downcaseTokens(s, l, t)"><variable ilk="argument" line="3495" name="s" /><variable ilk="argument" line="3495" name="l" /><variable ilk="argument" line="3495" name="t" /></scope><scope doc="Method to be called from within a parse action to determine the end&#10;location of the parsed tokens." ilk="function" line="3499" lineend="3513" name="getTokensEndLoc" signature="getTokensEndLoc()"><import line="3502" module="inspect" /><variable citdl="inspect.stack()" line="3503" name="fstack" /><variable line="3506" name="f" /><variable line="3508" name="endloc" /></scope><scope attributes="protected" doc="Internal helper to construct opening and closing tag expressions, given a tag name" ilk="function" line="3515" lineend="3542" name="_makeTags" returns="tuple" signature="_makeTags(tagStr, xml)"><variable citdl="Keyword" ilk="argument" line="3515" name="tagStr" /><variable ilk="argument" line="3515" name="xml" /><variable citdl="tagStr.name" line="3518" name="resname" /><variable citdl="Word" line="3523" name="tagAttrName" /><variable citdl="int" line="3525" name="tagAttrValue" /><variable line="3526" name="openTag" /><variable citdl="__builtins__.str.join()" line="3530" name="printablesLessRAbrack" /><variable citdl="Combine" line="3536" name="closeTag" /></scope><scope doc="Helper to construct opening and closing tag expressions for HTML, given a tag name" ilk="function" line="3544" lineend="3546" name="makeHTMLTags" returns="_makeTags()" signature="makeHTMLTags(tagStr)"><variable ilk="argument" line="3544" name="tagStr" /></scope><scope doc="Helper to construct opening and closing tag expressions for XML, given a tag name" ilk="function" line="3548" lineend="3550" name="makeXMLTags" returns="_makeTags()" signature="makeXMLTags(tagStr)"><variable ilk="argument" line="3548" name="tagStr" /></scope><scope doc="Helper to create a validating parse action to be used with start tags created&#10;with C{L{makeXMLTags}} or C{L{makeHTMLTags}}. Use C{withAttribute} to qualify a starting tag&#10;with a required attribute value, to avoid false matches on common tags such as&#10;C{&lt;TD&gt;} or C{&lt;DIV&gt;}.&#10;&#10;Call C{withAttribute} with a series of attribute names and values. Specify the list&#10;of filter attributes names and values as:&#10; - keyword arguments, as in C{(align=&quot;right&quot;)}, or&#10; - as an explicit dict with C{**} operator, when an attribute name is also a Python&#10;   reserved word, as in C{**{&quot;class&quot;:&quot;Customer&quot;, &quot;align&quot;:&quot;right&quot;}}&#10; - a list of name-value tuples, as in ( (&quot;ns1:class&quot;, &quot;Customer&quot;), (&quot;ns2:align&quot;,&quot;right&quot;) )&#10;For attribute names with a namespace prefix, you must use the second form.  Attribute&#10;names are matched insensitive to upper/lower case.&#10;&#10;If just testing for C{class} (with or without a namespace), use C{L{withClass}}.&#10;&#10;To verify that the attribute exists, but without specifying a value, pass&#10;C{withAttribute.ANY_VALUE} as the value." ilk="function" line="3552" lineend="3584" name="withAttribute" returns="withAttribute.pa" signature="withAttribute()"><variable citdl="list" line="3573" name="attrs" /><scope ilk="function" line="3577" lineend="3583" name="pa" signature="pa(s, l, tokens)"><variable ilk="argument" line="3577" name="s" /><variable ilk="argument" line="3577" name="l" /><variable ilk="argument" line="3577" name="tokens" /><variable line="3578" name="attrName" /><variable line="3578" name="attrValue" /></scope><variable citdl="object()" line="3585" name="ANY_VALUE" /></scope><scope doc="Simplified version of C{L{withAttribute}} when matching on a div class - made&#10;difficult because C{class} is a reserved word in Python." ilk="function" line="3587" lineend="3592" name="withClass" returns="withAttribute()" signature="withClass(classname, namespace='')"><variable ilk="argument" line="3587" name="classname" /><variable citdl="str" ilk="argument" line="3587" name="namespace" /><variable line="3591" name="classattr" /></scope><variable citdl="_Constants" line="3594" name="opAssoc" /><scope doc="Helper method for constructing grammars of expressions made up of&#10;operators working in a precedence hierarchy.  Operators may be unary or&#10;binary, left- or right-associative.  Parse actions can also be attached&#10;to operator expressions.&#10;&#10;Parameters:&#10; - baseExpr - expression representing the most basic element for the nested&#10; - opList - list of tuples, one for each operator precedence level in the&#10;   expression grammar; each tuple is of the form&#10;   (opExpr, numTerms, rightLeftAssoc, parseAction), where:&#10;    - opExpr is the pyparsing expression for the operator;&#10;       may also be a string, which will be converted to a Literal;&#10;       if numTerms is 3, opExpr is a tuple of two expressions, for the&#10;       two operators separating the 3 terms&#10;    - numTerms is the number of terms for this operator (must&#10;       be 1, 2, or 3)&#10;    - rightLeftAssoc is the indicator whether the operator is&#10;       right or left associative, using the pyparsing-defined&#10;       constants C{opAssoc.RIGHT} and C{opAssoc.LEFT}.&#10;    - parseAction is the parse action to be associated with&#10;       expressions matching this operator expression (the&#10;       parse action tuple member may be omitted)&#10; - lpar - expression for matching left-parentheses (default=Suppress('('))&#10; - rpar - expression for matching right-parentheses (default=Suppress(')'))" ilk="function" line="3598" lineend="3670" name="infixNotation" returns="Forward" signature="infixNotation(baseExpr, opList, lpar=Suppress('('), rpar=Suppress(')'))"><variable ilk="argument" line="3598" name="baseExpr" /><variable ilk="argument" line="3598" name="opList" /><variable citdl="Suppress" ilk="argument" line="3598" name="lpar" /><variable citdl="Suppress" ilk="argument" line="3598" name="rpar" /><variable citdl="Forward" line="3624" name="ret" /><variable citdl="int" line="3625" name="lastExpr" /><variable line="3626" name="operDef" /><variable line="3626" name="i" /><variable line="3628" name="termName" /><variable line="3633" name="thisExpr" /><variable line="3636" name="matchExpr" /><variable citdl="Optional" line="3651" name="opExpr" /></scope><variable citdl="infixNotation" line="3671" name="operatorPrecedence" /><variable line="3673" name="dblQuotedString" /><variable line="3674" name="sglQuotedString" /><variable line="3675" name="quotedString" /><variable line="3676" name="unicodeString" /><scope doc="Helper method for defining nested lists enclosed in opening and closing&#10;delimiters (&quot;(&quot; and &quot;)&quot; are the default).&#10;&#10;Parameters:&#10; - opener - opening character for a nested list (default=&quot;(&quot;); can also be a pyparsing expression&#10; - closer - closing character for a nested list (default=&quot;)&quot;); can also be a pyparsing expression&#10; - content - expression for items within the nested lists (default=None)&#10; - ignoreExpr - expression for ignoring opening and closing delimiters (default=quotedString)&#10;&#10;If an expression is not provided for the content argument, the nested&#10;expression will capture all whitespace-delimited content between delimiters&#10;as a list of separate values.&#10;&#10;Use the C{ignoreExpr} argument to define expressions that may contain&#10;opening or closing characters that should not be treated as opening&#10;or closing characters for nesting, such as quotedString or a comment&#10;expression.  Specify multiple expressions using an C{L{Or}} or C{L{MatchFirst}}.&#10;The default is L{quotedString}, but if no expressions are to be ignored,&#10;then pass C{None} for this argument." ilk="function" line="3678" lineend="3729" name="nestedExpr" returns="Forward" signature="nestedExpr(opener='(', closer=')', content=None, ignoreExpr=quotedString.copy())"><variable citdl="str" ilk="argument" line="3678" name="opener" /><variable citdl="str" ilk="argument" line="3678" name="closer" /><variable ilk="argument" line="3678" name="content" /><variable citdl="quotedString.copy()" ilk="argument" line="3678" name="ignoreExpr" /><variable citdl="Forward" line="3723" name="ret" /></scope><scope doc="Helper method for defining space-delimited indentation blocks, such as&#10;those used to define block statements in Python source code.&#10;&#10;Parameters:&#10; - blockStatementExpr - expression defining syntax of statement that&#10;     is repeated within the indented block&#10; - indentStack - list created by caller to manage indentation stack&#10;     (multiple statementWithIndentedBlock expressions within a single grammar&#10;     should share a common indentStack)&#10; - indent - boolean indicating whether block must be indented beyond the&#10;     the current level; set to False for block of left-most statements&#10;     (default=True)&#10;&#10;A valid block must contain at least one C{blockStatement}." ilk="function" line="3731" lineend="3781" name="indentedBlock" returns="smExpr.setName()" signature="indentedBlock(blockStatementExpr, indentStack, indent=True)"><variable ilk="argument" line="3731" name="blockStatementExpr" /><variable ilk="argument" line="3731" name="indentStack" /><variable citdl="True" ilk="argument" line="3731" name="indent" /><scope ilk="function" line="3747" lineend="3753" name="checkPeerIndent" signature="checkPeerIndent(s, l, t)"><variable ilk="argument" line="3747" name="s" /><variable ilk="argument" line="3747" name="l" /><variable ilk="argument" line="3747" name="t" /><variable citdl="col()" line="3749" name="curCol" /></scope><scope ilk="function" line="3755" lineend="3760" name="checkSubIndent" signature="checkSubIndent(s, l, t)"><variable ilk="argument" line="3755" name="s" /><variable ilk="argument" line="3755" name="l" /><variable ilk="argument" line="3755" name="t" /><variable citdl="col()" line="3756" name="curCol" /></scope><scope ilk="function" line="3762" lineend="3767" name="checkUnindent" signature="checkUnindent(s, l, t)"><variable ilk="argument" line="3762" name="s" /><variable ilk="argument" line="3762" name="l" /><variable ilk="argument" line="3762" name="t" /><variable citdl="col()" line="3764" name="curCol" /></scope><variable citdl="OneOrMore" line="3769" name="NL" /><variable line="3770" name="INDENT" /><variable line="3771" name="PEER" /><variable line="3772" name="UNDENT" /><variable citdl="Group" line="3774" name="smExpr" /></scope><variable citdl="srange()" line="3783" name="alphas8bit" /><variable citdl="srange()" line="3784" name="punc8bit" /><variable line="3786" name="anyCloseTag" /><variable line="3786" name="anyOpenTag" /><variable attributes="protected" citdl="dict()" line="3787" name="_htmlEntityMap" /><variable line="3788" name="commonHTMLEntity" /><scope doc="Helper parser action to replace common HTML entities with their special characters" ilk="function" line="3789" lineend="3791" name="replaceHTMLEntity" returns="_htmlEntityMap.get()" signature="replaceHTMLEntity(t)"><variable ilk="argument" line="3789" name="t" /></scope><variable line="3794" name="cStyleComment" /><variable line="3796" name="htmlComment" /><variable line="3797" name="restOfLine" /><variable line="3798" name="dblSlashComment" /><variable line="3799" name="cppStyleComment" /><variable line="3801" name="javaStyleComment" /><variable line="3802" name="pythonStyleComment" /><variable attributes="protected" line="3803" name="_commasepitem" /><variable line="3806" name="commaSeparatedList" /><variable citdl="CaselessLiteral" line="3811" name="selectToken" /><variable citdl="CaselessLiteral" line="3812" name="fromToken" /><variable citdl="Word" line="3814" name="ident" /><variable line="3815" name="columnName" /><variable line="3816" name="columnNameList" /><variable line="3817" name="tableName" /><variable line="3818" name="tableNameList" /><variable line="3819" name="simpleSQL" /></scope>