<scope doc="Cycler ======" ilk="blob" lang="Python" name="cycler" src="d:\Program Files (x86)\Python35-32\lib\site-packages\cycler.py"><import line="43" module="__future__" symbol="absolute_import" /><import line="43" module="__future__" symbol="division" /><import line="43" module="__future__" symbol="print_function" /><import line="43" module="__future__" symbol="unicode_literals" /><import line="46" module="six" /><import line="47" module="itertools" symbol="product" /><import line="47" module="itertools" symbol="cycle" /><import line="48" module="six.moves" symbol="zip" /><import line="48" module="six.moves" symbol="reduce" /><import line="49" module="operator" symbol="mul" /><import line="49" module="operator" symbol="add" /><import line="50" module="copy" /><variable citdl="str" line="52" name="__version__" /><scope attributes="protected" doc="Helper function to compose cycler keys&#10;&#10;Parameters&#10;----------&#10;left, right : iterable of dictionaries or None&#10;    The cyclers to be composed&#10;Returns&#10;-------&#10;keys : set&#10;    The keys in the composition of the two cyclers" ilk="function" line="55" lineend="74" name="_process_keys" returns="int" signature="_process_keys(left, right)"><variable ilk="argument" line="55" name="left" /><variable ilk="argument" line="55" name="right" /><variable line="68" name="l_peek" /><variable line="69" name="r_peek" /><variable citdl="set()" line="70" name="l_key" /><variable citdl="set()" line="71" name="r_key" /></scope><scope classrefs="object" doc="Composable cycles&#10;&#10;This class has compositions methods:&#10;&#10;``+``&#10;  for 'inner' products (zip)&#10;&#10;``+=``&#10;  in-place ``+``&#10;&#10;``*``&#10;  for outer products (itertools.product) and integer multiplication&#10;&#10;``*=``&#10;  in-place ``*``&#10;&#10;and supports basic slicing via ``[]``&#10;&#10;Parameters&#10;----------&#10;left : Cycler or None&#10;    The 'left' cycler&#10;&#10;right : Cycler or None&#10;    The 'right' cycler&#10;&#10;op : func or None&#10;    Function which composes the 'left' and 'right' cyclers." ilk="class" line="77" lineend="425" name="Cycler"><scope ilk="function" line="109" lineend="110" name="__call__" returns="cycle()" signature="__call__()"><variable citdl="Cycler" ilk="argument" line="109" name="self" /></scope><scope attributes="__ctor__" doc="Semi-private init&#10;&#10;Do not use this directly, use `cycler` function instead." ilk="function" line="112" lineend="136" name="__init__" signature="Cycler(left, right=None, op=None)"><variable citdl="Cycler" ilk="argument" line="112" name="self" /><variable ilk="argument" line="112" name="left" /><variable ilk="argument" line="112" name="right" /><variable ilk="argument" line="112" name="op" /></scope><variable attributes="protected __instancevar__" citdl="list" line="118" name="_left" /><variable attributes="protected __instancevar__" citdl="" line="127" name="_right" /><variable attributes="protected __instancevar__" citdl="_process_keys()" line="135" name="_keys" /><variable attributes="protected __instancevar__" citdl="zip" line="136" name="_op" /><scope attributes="__hidden__" doc="The keys this Cycler knows about" ilk="function" line="138" lineend="138" name="keys (property getter)" returns="set()" signature="keys (property getter)()"><variable citdl="Cycler" ilk="argument" line="138" name="self" /></scope><variable attributes="property" citdl="set()" line="138" name="keys" /><scope doc="Change a key in this cycler to a new name.&#10;Modification is performed in-place.&#10;&#10;Does nothing if the old key is the same as the new key.&#10;Raises a ValueError if the new key is already a key.&#10;Raises a KeyError if the old key isn't a key." ilk="function" line="145" lineend="178" name="change_key" signature="change_key(old, new)"><variable citdl="Cycler" ilk="argument" line="145" name="self" /><variable ilk="argument" line="145" name="old" /><variable ilk="argument" line="145" name="new" /></scope><scope attributes="protected" doc="Compose the 'left' and 'right' components of this cycle&#10;with the proper operation (zip or product as of now)" ilk="function" line="180" lineend="189" name="_compose" signature="_compose()"><variable citdl="Cycler" ilk="argument" line="180" name="self" /><variable line="185" name="b" /><variable line="185" name="a" /><variable citdl="dict()" line="186" name="out" /></scope><scope attributes="protected __classmethod__" doc="Class method to create 'base' Cycler objects&#10;that do not have a 'right' or 'op' and for which&#10;the 'left' object is not another Cycler.&#10;&#10;Parameters&#10;----------&#10;label : str&#10;    The property key.&#10;&#10;itr : iterable&#10;    Finite length iterable of the property values.&#10;&#10;Returns&#10;-------&#10;cycler : Cycler&#10;    New 'base' `Cycler`" ilk="function" line="191" lineend="191" name="_from_iter" returns="cls()" signature="_from_iter(label, itr) - classmethod"><variable citdl="Cycler" ilk="argument" line="191" name="cls" /><variable ilk="argument" line="191" name="label" /><variable ilk="argument" line="191" name="itr" /><variable citdl="cls()" line="211" name="ret" /></scope><scope ilk="function" line="216" lineend="223" name="__getitem__" returns="reduce()" signature="__getitem__(key)"><variable citdl="Cycler" ilk="argument" line="216" name="self" /><variable ilk="argument" line="216" name="key" /><variable citdl="self.by_key()" line="219" name="trans" /></scope><scope ilk="function" line="225" lineend="229" name="__iter__" returns="Cycler._compose()" signature="__iter__()"><variable citdl="Cycler" ilk="argument" line="225" name="self" /></scope><scope doc="Pair-wise combine two equal length cycles (zip)&#10;&#10;Parameters&#10;----------&#10;other : Cycler&#10;   The second Cycler" ilk="function" line="231" lineend="243" name="__add__" returns="Cycler" signature="__add__(other)"><variable citdl="Cycler" ilk="argument" line="231" name="self" /><variable ilk="argument" line="231" name="other" /></scope><scope doc="Outer product of two cycles (`itertools.product`) or integer&#10;multiplication.&#10;&#10;Parameters&#10;----------&#10;other : Cycler or int&#10;   The second Cycler or integer" ilk="function" line="245" lineend="262" name="__mul__" returns="NotImplemented" signature="__mul__(other)"><variable citdl="Cycler" ilk="argument" line="245" name="self" /><variable ilk="argument" line="245" name="other" /><variable citdl="self.by_key()" line="258" name="trans" /></scope><scope ilk="function" line="264" lineend="265" name="__rmul__" signature="__rmul__(other)"><variable citdl="Cycler" ilk="argument" line="264" name="self" /><variable ilk="argument" line="264" name="other" /></scope><scope ilk="function" line="267" lineend="273" name="__len__" returns="len()" signature="__len__()"><variable citdl="Cycler" ilk="argument" line="267" name="self" /><variable citdl="dict" line="268" name="op_dict" /><variable citdl="len()" line="271" name="l_len" /><variable citdl="len()" line="272" name="r_len" /></scope><scope doc="In-place pair-wise combine two equal length cycles (zip)&#10;&#10;Parameters&#10;----------&#10;other : Cycler&#10;   The second Cycler" ilk="function" line="275" lineend="292" name="__iadd__" returns="Cycler" signature="__iadd__(other)"><variable citdl="Cycler" ilk="argument" line="275" name="self" /><variable ilk="argument" line="275" name="other" /><variable citdl="copy.copy()" line="287" name="old_self" /></scope><scope doc="In-place outer product of two cycles (`itertools.product`)&#10;&#10;Parameters&#10;----------&#10;other : Cycler&#10;   The second Cycler" ilk="function" line="294" lineend="311" name="__imul__" returns="Cycler" signature="__imul__(other)"><variable citdl="Cycler" ilk="argument" line="294" name="self" /><variable ilk="argument" line="294" name="other" /><variable citdl="copy.copy()" line="306" name="old_self" /></scope><scope doc="Check equality" ilk="function" line="313" lineend="322" name="__eq__" returns="bool" signature="__eq__(other)"><variable citdl="Cycler" ilk="argument" line="313" name="self" /><variable ilk="argument" line="313" name="other" /></scope><scope ilk="function" line="324" lineend="333" name="__repr__" returns="msg.format()" signature="__repr__()"><variable citdl="Cycler" ilk="argument" line="324" name="self" /><variable citdl="dict" line="325" name="op_map" /><variable citdl="self.keys.pop()" line="327" name="lab" /><variable citdl="list()" line="328" name="itr" /><variable citdl="op_map.get()" line="331" name="op" /><variable citdl="str" line="332" name="msg" /></scope><scope attributes="protected" ilk="function" line="335" lineend="347" name="_repr_html_" returns="str" signature="_repr_html_()"><variable citdl="Cycler" ilk="argument" line="335" name="self" /><variable citdl="str" line="337" name="output" /><variable citdl="sorted()" line="338" name="sorted_keys" /><variable line="339" name="key" /><variable line="341" name="d" /><variable line="343" name="k" /></scope><scope doc="Values by key&#10;&#10;This returns the transposed values of the cycler.  Iterating&#10;over a `Cycler` yields dicts with a single value for each key,&#10;this method returns a `dict` of `list` which are the values&#10;for the given key.&#10;&#10;The returned value can be used to create an equivalent `Cycler`&#10;using only `+`.&#10;&#10;Returns&#10;-------&#10;transpose : dict&#10;    dict of lists of the values for each key." ilk="function" line="349" lineend="376" name="by_key" returns="dict()" signature="by_key()"><variable citdl="Cycler" ilk="argument" line="349" name="self" /><variable citdl="set()" line="369" name="keys" /><variable citdl="dict()" line="371" name="out" /><variable line="373" name="d" /><variable line="374" name="k" /></scope><variable attributes="protected" citdl="Cycler.by_key" line="379" name="_transpose" /><scope doc="Simplify the Cycler&#10;&#10;Returned as a composition using only sums (no multiplications)&#10;&#10;Returns&#10;-------&#10;simple : Cycler&#10;    An equivalent cycler using only summation" ilk="function" line="381" lineend="397" name="simplify" returns="reduce()" signature="simplify()"><variable citdl="Cycler" ilk="argument" line="381" name="self" /><variable citdl="by_key()" line="396" name="trans" /></scope><scope doc="Concatenate this cycler and an other.&#10;&#10;The keys must match exactly.&#10;&#10;This returns a single Cycler which is equivalent to&#10;`itertools.chain(self, other)`&#10;&#10;Examples&#10;--------&#10;&#10;&gt;&gt;&gt; num = cycler('a', range(3))&#10;&gt;&gt;&gt; let = cycler('a', 'abc')&#10;&gt;&gt;&gt; num.concat(let)&#10;cycler('a', [0, 1, 2, 'a', 'b', 'c'])&#10;&#10;Parameters&#10;----------&#10;other : `Cycler`&#10;    The `Cycler` to concatenate to this one.&#10;&#10;Returns&#10;-------&#10;ret : `Cycler`&#10;    The concatenated `Cycler`" ilk="function" line="399" lineend="425" name="concat" returns="Cycler.concat()" signature="concat(other)"><variable citdl="Cycler" ilk="argument" line="399" name="self" /><variable ilk="argument" line="399" name="other" /></scope></scope><scope doc="Concatenate two cyclers.&#10;&#10;The keys must match exactly.&#10;&#10;This returns a single Cycler which is equivalent to&#10;`itertools.chain(left, right)`&#10;&#10;Examples&#10;--------&#10;&#10;&gt;&gt;&gt; num = cycler('a', range(3))&#10;&gt;&gt;&gt; let = cycler('a', 'abc')&#10;&gt;&gt;&gt; num.concat(let)&#10;cycler('a', [0, 1, 2, 'a', 'b', 'c'])&#10;&#10;Parameters&#10;----------&#10;left, right : `Cycler`&#10;    The two `Cycler` instances to concatenate&#10;&#10;Returns&#10;-------&#10;ret : `Cycler`&#10;    The concatenated `Cycler`" ilk="function" line="428" lineend="465" name="concat" returns="reduce()" signature="concat(left, right)"><variable ilk="argument" line="428" name="left" /><variable ilk="argument" line="428" name="right" /><variable line="455" name="msg" /><variable attributes="protected" citdl="left.by_key()" line="463" name="_l" /><variable attributes="protected" citdl="right.by_key()" line="464" name="_r" /></scope><scope doc="Create a new `Cycler` object from a single positional argument,&#10;a pair of positional arguments, or the combination of keyword arguments.&#10;&#10;cycler(arg)&#10;cycler(label1=itr1[, label2=iter2[, ...]])&#10;cycler(label, itr)&#10;&#10;Form 1 simply copies a given `Cycler` object.&#10;&#10;Form 2 composes a `Cycler` as an inner product of the&#10;pairs of keyword arguments. In other words, all of the&#10;iterables are cycled simultaneously, as if through zip().&#10;&#10;Form 3 creates a `Cycler` from a label and an iterable.&#10;This is useful for when the label cannot be a keyword argument&#10;(e.g., an integer or a name that has a space in it).&#10;&#10;Parameters&#10;----------&#10;arg : Cycler&#10;    Copy constructor for Cycler (does a shallow copy of iterables).&#10;&#10;label : name&#10;    The property key. In the 2-arg form of the function,&#10;    the label can be any hashable object. In the keyword argument&#10;    form of the function, it must be a valid python identifier.&#10;&#10;itr : iterable&#10;    Finite length iterable of the property values.&#10;    Can be a single-property `Cycler` that would&#10;    be like a key change, but as a shallow copy.&#10;&#10;Returns&#10;-------&#10;cycler : Cycler&#10;    New `Cycler` for the given property" ilk="function" line="468" lineend="526" name="cycler" returns="_cycler()" signature="cycler()" /><scope attributes="protected" doc="Create a new `Cycler` object from a property name and&#10;iterable of values.&#10;&#10;Parameters&#10;----------&#10;label : hashable&#10;    The property key.&#10;&#10;itr : iterable&#10;    Finite length iterable of the property values.&#10;&#10;Returns&#10;-------&#10;cycler : Cycler&#10;    New `Cycler` for the given property" ilk="function" line="529" lineend="558" name="_cycler" returns="Cycler._from_iter()" signature="_cycler(label, itr)"><variable ilk="argument" line="529" name="label" /><variable ilk="argument" line="529" name="itr" /><variable citdl="itr.keys" line="548" name="keys" /><variable citdl="str" line="550" name="msg" /><variable citdl="keys.pop()" line="553" name="lab" /></scope></scope>