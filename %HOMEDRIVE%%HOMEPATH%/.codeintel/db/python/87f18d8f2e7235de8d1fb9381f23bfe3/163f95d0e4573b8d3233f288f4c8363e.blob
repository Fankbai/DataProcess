<scope doc="============================ ``ctypes`` Utility Functions&#10;============================" ilk="blob" lang="Python" name="ctypeslib" src="d:\Program Files (x86)\Python35-32\lib\site-packages\numpy\ctypeslib.py"><import line="52" module="__future__" symbol="division" /><import line="52" module="__future__" symbol="absolute_import" /><import line="52" module="__future__" symbol="print_function" /><import line="57" module="sys" /><import line="57" module="os" /><import line="58" module="numpy" symbol="integer" /><import line="58" module="numpy" symbol="ndarray" /><import alias="_dtype" line="58" module="numpy" symbol="dtype" /><import line="58" module="numpy" symbol="deprecate" /><import line="58" module="numpy" symbol="array" /><import line="59" module="numpy.core.multiarray" symbol="_flagdict" /><import line="59" module="numpy.core.multiarray" symbol="flagsobj" /><import line="62" module="ctypes" /><import alias="c_intp" line="82" module="numpy" symbol="intp" /><import alias="nic" line="85" module="numpy.core._internal" /><variable citdl="list" line="54" name="__all__" /><variable line="64" name="ctypes" /><scope attributes="protected" doc="Dummy object that raises an ImportError if ctypes is not available.&#10;&#10;Raises&#10;------&#10;ImportError&#10;    If ctypes is not available." ilk="function" line="67" lineend="77" name="_dummy" signature="_dummy()" /><variable citdl="deprecate()" line="78" name="ctypes_load_library" /><variable attributes="protected" citdl="ctypes.c_void_p" line="83" name="_ndptr_base" /><variable citdl="nic._getintp_ctype()" line="86" name="c_intp" /><scope ilk="function" line="91" lineend="128" name="load_library" signature="load_library(libname, loader_path)"><import line="93" module="warnings" /><import line="102" module="numpy.distutils.misc_util" symbol="get_shared_lib_extension" /><variable ilk="argument" line="91" name="libname" /><variable citdl="os.path.abspath()" ilk="argument" line="91" name="loader_path" /><variable line="97" name="ext" /><variable citdl="get_shared_lib_extension()" line="103" name="so_ext" /><variable citdl="list" line="104" name="libname_ext" /><variable citdl="get_shared_lib_extension()" line="107" name="so_ext2" /><variable citdl="os.path.dirname()" line="115" name="libdir" /><variable line="119" name="ln" /><variable citdl="os.path.join()" line="120" name="libpath" /></scope><scope attributes="protected" ilk="function" line="133" lineend="137" name="_num_fromflags" returns="int" signature="_num_fromflags(flaglist)"><variable ilk="argument" line="133" name="flaglist" /><variable citdl="int" line="134" name="num" /><variable line="135" name="val" /></scope><variable attributes="protected" citdl="list" line="139" name="_flagnames" /><scope attributes="protected" ilk="function" line="141" lineend="147" name="_flags_fromnum" returns="list" signature="_flags_fromnum(num)"><variable ilk="argument" line="141" name="num" /><variable citdl="list" line="142" name="res" /><variable line="143" name="key" /><variable line="144" name="value" /></scope><scope attributes="protected" classrefs="ctypes.c_void_p" ilk="class" line="150" lineend="169" name="_ndptr"><scope attributes="protected" doc="This method is called when this class is used as the .restype&#10;asttribute for a shared-library function.   It constructs a numpy&#10;array from a void pointer." ilk="function" line="152" lineend="156" name="_check_retval_" returns="array()" signature="_check_retval_()"><variable citdl="_ndptr" ilk="argument" line="152" name="self" /></scope><variable attributes="property" citdl="dict" line="158" name="__array_interface__" /><scope attributes="__hidden__" ilk="function" line="158" lineend="158" name="__array_interface__ (property getter)" returns="dict" signature="__array_interface__ (property getter)()"><variable citdl="_ndptr" ilk="argument" line="158" name="self" /></scope><scope attributes="__classmethod__" ilk="function" line="169" lineend="169" name="from_param" returns="obj.ctypes" signature="from_param(obj) - classmethod"><variable citdl="_ndptr" ilk="argument" line="169" name="cls" /><variable ilk="argument" line="169" name="obj" /></scope></scope><variable attributes="protected" citdl="dict" line="191" name="_pointer_type_cache" /><scope doc="Array-checking restype/argtypes.&#10;&#10;An ndpointer instance is used to describe an ndarray in restypes&#10;and argtypes specifications.  This approach is more flexible than&#10;using, for example, ``POINTER(c_double)``, since several restrictions&#10;can be specified, which are verified upon calling the ctypes function.&#10;These include data type, number of dimensions, shape and flags.  If a&#10;given array does not satisfy the specified restrictions,&#10;a ``TypeError`` is raised.&#10;&#10;Parameters&#10;----------&#10;dtype : data-type, optional&#10;    Array data-type.&#10;ndim : int, optional&#10;    Number of array dimensions.&#10;shape : tuple of ints, optional&#10;    Array shape.&#10;flags : str or tuple of str&#10;    Array flags; may be one or more of:&#10;&#10;      - C_CONTIGUOUS / C / CONTIGUOUS&#10;      - F_CONTIGUOUS / F / FORTRAN&#10;      - OWNDATA / O&#10;      - WRITEABLE / W&#10;      - ALIGNED / A&#10;      - UPDATEIFCOPY / U&#10;&#10;Returns&#10;-------&#10;klass : ndpointer type object&#10;    A type object, which is an ``_ndtpr`` instance containing&#10;    dtype, ndim, shape and flags information.&#10;&#10;Raises&#10;------&#10;TypeError&#10;    If a given array does not satisfy the specified restrictions.&#10;&#10;Examples&#10;--------&#10;&gt;&gt;&gt; clib.somefunc.argtypes = [np.ctypeslib.ndpointer(dtype=np.float64,&#10;...                                                  ndim=1,&#10;...                                                  flags='C_CONTIGUOUS')]&#10;... #doctest: +SKIP&#10;&gt;&gt;&gt; clib.somefunc(np.array([1, 2, 3], dtype=np.float64))&#10;... #doctest: +SKIP" ilk="function" line="192" lineend="292" name="ndpointer" returns="type()" signature="ndpointer(dtype=None, ndim=None, shape=None, flags=None)"><variable citdl="_dtype()" ilk="argument" line="192" name="dtype" /><variable ilk="argument" line="192" name="ndim" /><variable citdl="tuple" ilk="argument" line="192" name="shape" /><variable citdl="list" ilk="argument" line="192" name="flags" /><variable citdl="flags.num" line="246" name="num" /><variable citdl="str" line="267" name="name" /><variable citdl="list" line="276" name="strshape" /><variable citdl="type()" line="286" name="klass" /></scope><variable line="295" name="ct" /><variable attributes="protected" citdl="dict" line="301" name="_typecodes" /><scope doc="Given a ctypes simple type, construct and attach an&#10;__array_interface__ property to it if it does not yet have one." ilk="function" line="303" lineend="324" name="prep_simple" signature="prep_simple(simple_type, dtype)"><variable ilk="argument" line="303" name="simple_type" /><variable ilk="argument" line="303" name="dtype" /><variable line="311" name="typestr" /><scope ilk="function" line="314" lineend="321" name="__array_interface__" returns="dict" signature="__array_interface__(self)"><variable ilk="argument" line="314" name="self" /></scope></scope><variable citdl="list" line="326" name="simple_types" /><variable line="333" name="types" /><variable line="333" name="code" /><variable line="334" name="tp" /><variable attributes="protected" citdl="type()" line="340" name="_ARRAY_TYPE" /><scope doc="Given a ctypes array type, construct and attach an&#10;__array_interface__ property to it if it does not yet have one." ilk="function" line="342" lineend="370" name="prep_array" signature="prep_array(array_type)"><variable ilk="argument" line="342" name="array_type" /><variable citdl="list" line="350" name="shape" /><variable citdl="ob._type_" line="351" name="ob" /><variable line="356" name="ai" /><variable line="357" name="descr" /><variable line="358" name="typestr" /><scope ilk="function" line="360" lineend="367" name="__array_interface__" returns="dict" signature="__array_interface__(self)"><variable ilk="argument" line="360" name="self" /></scope></scope><scope doc="Given a ctypes pointer object, construct and&#10;attach an __array_interface__ property to it if it does not&#10;yet have one." ilk="function" line="372" lineend="389" name="prep_pointer" signature="prep_pointer(pointer_obj, shape)"><variable ilk="argument" line="372" name="pointer_obj" /><variable ilk="argument" line="372" name="shape" /><variable citdl="pointer_obj.contents" line="381" name="contents" /><variable citdl="_dtype()" line="382" name="dtype" /><variable citdl="dict" line="384" name="inter" /></scope><scope doc="Create a numpy array from a ctypes array or a ctypes POINTER.&#10;The numpy array shares the memory with the ctypes object.&#10;&#10;The size parameter must be given if converting from a ctypes POINTER.&#10;The size parameter is ignored if converting from a ctypes array" ilk="function" line="394" lineend="408" name="as_array" returns="array()" signature="as_array(obj, shape=None)"><variable ilk="argument" line="394" name="obj" /><variable ilk="argument" line="394" name="shape" /><variable citdl="type()" line="401" name="tp" /></scope><scope doc="Create and return a ctypes object from a numpy array.  Actually&#10;anything that exposes the __array_interface__ is accepted." ilk="function" line="410" lineend="426" name="as_ctypes" returns="tp.from_address()" signature="as_ctypes(obj)"><variable ilk="argument" line="410" name="obj" /><variable citdl="obj.__array_interface__" line="413" name="ai" /><variable line="421" name="tp" /><variable line="422" name="dim" /><variable citdl="tp.from_address()" line="424" name="result" /></scope></scope>